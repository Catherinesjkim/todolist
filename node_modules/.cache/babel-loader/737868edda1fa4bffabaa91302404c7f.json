{"ast":null,"code":"import _bindInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/bind\";\nimport _Date$now from \"@babel/runtime-corejs3/core-js-stable/date/now\";\nimport _Object$keys from \"@babel/runtime-corejs3/core-js-stable/object/keys\";\nimport _forEachInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/for-each\";\nimport _concatInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/concat\";\nimport logFactory from '../utils/logger';\nvar log = logFactory('splitio-client');\nimport { evaluateFeature, evaluateFeatures } from '../engine/evaluator';\nimport ImpressionTracker from '../trackers/impression';\nimport ImpressionsTracker from '../trackers/impressions';\nimport tracker from '../utils/timeTracker';\nimport thenable from '../utils/promise/thenable';\nimport { matching, bucketing } from '../utils/key/factory';\n/* asynchronous validations that live on the client. */\n\nimport { validateSplitExistance, validateTrafficTypeExistance } from '../utils/inputValidation';\nimport { SDK_NOT_READY } from '../utils/labels';\nimport { CONTROL } from '../utils/constants';\n\nfunction queueEventsCallback(_ref, tracked) {\n  var _context, _context2, _context3, _context4, _context5;\n\n  var eventTypeId = _ref.eventTypeId,\n      trafficTypeName = _ref.trafficTypeName,\n      key = _ref.key,\n      value = _ref.value,\n      timestamp = _ref.timestamp,\n      properties = _ref.properties; // Logging every prop would be too much.\n\n  var msg = _concatInstanceProperty(_context = _concatInstanceProperty(_context2 = _concatInstanceProperty(_context3 = _concatInstanceProperty(_context4 = _concatInstanceProperty(_context5 = \"event of type \\\"\".concat(eventTypeId, \"\\\" for traffic type \\\"\")).call(_context5, trafficTypeName, \"\\\". Key: \")).call(_context4, key, \". Value: \")).call(_context3, value, \". Timestamp: \")).call(_context2, timestamp, \". \")).call(_context, properties ? 'With properties.' : 'With no properties.');\n\n  if (tracked) {\n    log.info(\"Successfully qeued \".concat(msg));\n  } else {\n    log.warn(\"Failed to queue \".concat(msg));\n  }\n\n  return tracked;\n}\n\nfunction ClientFactory(context) {\n  var storage = context.get(context.constants.STORAGE);\n  var metricCollectors = context.get(context.constants.COLLECTORS);\n  var impressionTracker = ImpressionTracker(context);\n  var impressionsTracker = ImpressionsTracker(context);\n\n  function getTreatment(key, splitName, attributes) {\n    var withConfig = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    var taskToBeTracked = tracker.TaskNames[withConfig ? 'SDK_GET_TREATMENT_WITH_CONFIG' : 'SDK_GET_TREATMENT'];\n    var stopLatencyTracker = tracker.start(taskToBeTracked, metricCollectors);\n    var evaluation = evaluateFeature(key, splitName, attributes, storage);\n\n    if (thenable(evaluation)) {\n      return evaluation.then(function (res) {\n        return processEvaluation(res, splitName, key, attributes, stopLatencyTracker, impressionTracker.track, withConfig, \"getTreatment\".concat(withConfig ? 'withConfig' : ''));\n      });\n    } else {\n      return processEvaluation(evaluation, splitName, key, attributes, stopLatencyTracker, impressionTracker.track, withConfig, \"getTreatment\".concat(withConfig ? 'withConfig' : ''));\n    }\n  }\n\n  function getTreatmentWithConfig(key, splitName, attributes) {\n    return getTreatment(key, splitName, attributes, true);\n  }\n\n  function getTreatments(key, splitNames, attributes) {\n    var withConfig = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    var taskToBeTracked = tracker.TaskNames[withConfig ? 'SDK_GET_TREATMENTS_WITH_CONFIG' : 'SDK_GET_TREATMENTS'];\n    var stopLatencyTracker = tracker.start(taskToBeTracked, metricCollectors);\n    var results = {};\n\n    var wrapUp = function wrapUp(evaluationResults) {\n      var _context6;\n\n      _forEachInstanceProperty(_context6 = _Object$keys(evaluationResults)).call(_context6, function (splitName) {\n        results[splitName] = processEvaluation(evaluationResults[splitName], splitName, key, attributes, false, impressionsTracker.queue, withConfig, \"getTreatments\".concat(withConfig ? 'withConfig' : ''));\n      });\n\n      impressionsTracker.track();\n      stopLatencyTracker();\n      return results;\n    };\n\n    var evaluations = evaluateFeatures(key, splitNames, attributes, storage);\n    return thenable(evaluations) ? evaluations.then(function (res) {\n      return wrapUp(res);\n    }) : wrapUp(evaluations);\n  }\n\n  function getTreatmentsWithConfig(key, splitNames, attributes) {\n    return getTreatments(key, splitNames, attributes, true);\n  } // Internal function\n\n\n  function processEvaluation(evaluation, splitName, key, attributes) {\n    var _context7, _context8, _context9;\n\n    var stopLatencyTracker = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    var impressionsTracker = arguments.length > 5 ? arguments[5] : undefined;\n    var withConfig = arguments.length > 6 ? arguments[6] : undefined;\n    var invokingMethodName = arguments.length > 7 ? arguments[7] : undefined;\n    var isSdkReady = context.get(context.constants.READY, true) || context.get(context.constants.READY_FROM_CACHE, true);\n    var matchingKey = matching(key);\n    var bucketingKey = bucketing(key); // If the SDK was not ready, treatment may be incorrect due to having Splits but not segments data.\n\n    if (!isSdkReady) {\n      evaluation = {\n        treatment: CONTROL,\n        label: SDK_NOT_READY\n      };\n    }\n\n    var _evaluation = evaluation,\n        treatment = _evaluation.treatment,\n        label = _evaluation.label,\n        changeNumber = _evaluation.changeNumber,\n        _evaluation$config = _evaluation.config,\n        config = _evaluation$config === void 0 ? null : _evaluation$config;\n    log.info(_concatInstanceProperty(_context7 = _concatInstanceProperty(_context8 = _concatInstanceProperty(_context9 = \"Split: \".concat(splitName, \". Key: \")).call(_context9, matchingKey, \". Evaluation: \")).call(_context8, treatment, \". Label: \")).call(_context7, label));\n\n    if (validateSplitExistance(context, splitName, label, invokingMethodName)) {\n      log.info('Queueing corresponding impression.');\n      impressionsTracker({\n        feature: splitName,\n        keyName: matchingKey,\n        treatment: treatment,\n        time: _Date$now(),\n        bucketingKey: bucketingKey,\n        label: label,\n        changeNumber: changeNumber\n      }, attributes);\n    }\n\n    stopLatencyTracker && stopLatencyTracker();\n\n    if (withConfig) {\n      return {\n        treatment: treatment,\n        config: config\n      };\n    }\n\n    return treatment;\n  }\n\n  function track(key, trafficTypeName, eventTypeId) {\n    var value = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    var properties = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    var size = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1024;\n    var matchingKey = matching(key);\n\n    var timestamp = _Date$now();\n\n    var eventData = {\n      eventTypeId: eventTypeId,\n      trafficTypeName: trafficTypeName,\n      value: value,\n      timestamp: timestamp,\n      key: matchingKey,\n      properties: properties\n    }; // This may be async but we only warn, we don't actually care if it is valid or not in terms of queueing the event.\n\n    validateTrafficTypeExistance(trafficTypeName, context, 'track');\n    var tracked = storage.events.track(eventData, size);\n\n    if (thenable(tracked)) {\n      return tracked.then(_bindInstanceProperty(queueEventsCallback).call(queueEventsCallback, null, eventData));\n    } else {\n      return queueEventsCallback(eventData, tracked);\n    }\n  }\n\n  return {\n    getTreatment: getTreatment,\n    getTreatmentWithConfig: getTreatmentWithConfig,\n    getTreatments: getTreatments,\n    getTreatmentsWithConfig: getTreatmentsWithConfig,\n    track: track\n  };\n}\n\nexport default ClientFactory;","map":{"version":3,"sources":["/Users/talianassi/node_modules/@splitsoftware/splitio/es/client/client.js"],"names":["_bindInstanceProperty","_Date$now","_Object$keys","_forEachInstanceProperty","_concatInstanceProperty","logFactory","log","evaluateFeature","evaluateFeatures","ImpressionTracker","ImpressionsTracker","tracker","thenable","matching","bucketing","validateSplitExistance","validateTrafficTypeExistance","SDK_NOT_READY","CONTROL","queueEventsCallback","_ref","tracked","_context","_context2","_context3","_context4","_context5","eventTypeId","trafficTypeName","key","value","timestamp","properties","msg","concat","call","info","warn","ClientFactory","context","storage","get","constants","STORAGE","metricCollectors","COLLECTORS","impressionTracker","impressionsTracker","getTreatment","splitName","attributes","withConfig","arguments","length","undefined","taskToBeTracked","TaskNames","stopLatencyTracker","start","evaluation","then","res","processEvaluation","track","getTreatmentWithConfig","getTreatments","splitNames","results","wrapUp","evaluationResults","_context6","queue","evaluations","getTreatmentsWithConfig","_context7","_context8","_context9","invokingMethodName","isSdkReady","READY","READY_FROM_CACHE","matchingKey","bucketingKey","treatment","label","_evaluation","changeNumber","_evaluation$config","config","feature","keyName","time","size","eventData","events"],"mappings":"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","sourcesContent":["import _bindInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/bind\";\nimport _Date$now from \"@babel/runtime-corejs3/core-js-stable/date/now\";\nimport _Object$keys from \"@babel/runtime-corejs3/core-js-stable/object/keys\";\nimport _forEachInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/for-each\";\nimport _concatInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/concat\";\nimport logFactory from '../utils/logger';\nvar log = logFactory('splitio-client');\nimport { evaluateFeature, evaluateFeatures } from '../engine/evaluator';\nimport ImpressionTracker from '../trackers/impression';\nimport ImpressionsTracker from '../trackers/impressions';\nimport tracker from '../utils/timeTracker';\nimport thenable from '../utils/promise/thenable';\nimport { matching, bucketing } from '../utils/key/factory';\n/* asynchronous validations that live on the client. */\n\nimport { validateSplitExistance, validateTrafficTypeExistance } from '../utils/inputValidation';\nimport { SDK_NOT_READY } from '../utils/labels';\nimport { CONTROL } from '../utils/constants';\n\nfunction queueEventsCallback(_ref, tracked) {\n  var _context, _context2, _context3, _context4, _context5;\n\n  var eventTypeId = _ref.eventTypeId,\n      trafficTypeName = _ref.trafficTypeName,\n      key = _ref.key,\n      value = _ref.value,\n      timestamp = _ref.timestamp,\n      properties = _ref.properties;\n\n  // Logging every prop would be too much.\n  var msg = _concatInstanceProperty(_context = _concatInstanceProperty(_context2 = _concatInstanceProperty(_context3 = _concatInstanceProperty(_context4 = _concatInstanceProperty(_context5 = \"event of type \\\"\".concat(eventTypeId, \"\\\" for traffic type \\\"\")).call(_context5, trafficTypeName, \"\\\". Key: \")).call(_context4, key, \". Value: \")).call(_context3, value, \". Timestamp: \")).call(_context2, timestamp, \". \")).call(_context, properties ? 'With properties.' : 'With no properties.');\n\n  if (tracked) {\n    log.info(\"Successfully qeued \".concat(msg));\n  } else {\n    log.warn(\"Failed to queue \".concat(msg));\n  }\n\n  return tracked;\n}\n\nfunction ClientFactory(context) {\n  var storage = context.get(context.constants.STORAGE);\n  var metricCollectors = context.get(context.constants.COLLECTORS);\n  var impressionTracker = ImpressionTracker(context);\n  var impressionsTracker = ImpressionsTracker(context);\n\n  function getTreatment(key, splitName, attributes) {\n    var withConfig = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    var taskToBeTracked = tracker.TaskNames[withConfig ? 'SDK_GET_TREATMENT_WITH_CONFIG' : 'SDK_GET_TREATMENT'];\n    var stopLatencyTracker = tracker.start(taskToBeTracked, metricCollectors);\n    var evaluation = evaluateFeature(key, splitName, attributes, storage);\n\n    if (thenable(evaluation)) {\n      return evaluation.then(function (res) {\n        return processEvaluation(res, splitName, key, attributes, stopLatencyTracker, impressionTracker.track, withConfig, \"getTreatment\".concat(withConfig ? 'withConfig' : ''));\n      });\n    } else {\n      return processEvaluation(evaluation, splitName, key, attributes, stopLatencyTracker, impressionTracker.track, withConfig, \"getTreatment\".concat(withConfig ? 'withConfig' : ''));\n    }\n  }\n\n  function getTreatmentWithConfig(key, splitName, attributes) {\n    return getTreatment(key, splitName, attributes, true);\n  }\n\n  function getTreatments(key, splitNames, attributes) {\n    var withConfig = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    var taskToBeTracked = tracker.TaskNames[withConfig ? 'SDK_GET_TREATMENTS_WITH_CONFIG' : 'SDK_GET_TREATMENTS'];\n    var stopLatencyTracker = tracker.start(taskToBeTracked, metricCollectors);\n    var results = {};\n\n    var wrapUp = function wrapUp(evaluationResults) {\n      var _context6;\n\n      _forEachInstanceProperty(_context6 = _Object$keys(evaluationResults)).call(_context6, function (splitName) {\n        results[splitName] = processEvaluation(evaluationResults[splitName], splitName, key, attributes, false, impressionsTracker.queue, withConfig, \"getTreatments\".concat(withConfig ? 'withConfig' : ''));\n      });\n\n      impressionsTracker.track();\n      stopLatencyTracker();\n      return results;\n    };\n\n    var evaluations = evaluateFeatures(key, splitNames, attributes, storage);\n    return thenable(evaluations) ? evaluations.then(function (res) {\n      return wrapUp(res);\n    }) : wrapUp(evaluations);\n  }\n\n  function getTreatmentsWithConfig(key, splitNames, attributes) {\n    return getTreatments(key, splitNames, attributes, true);\n  } // Internal function\n\n\n  function processEvaluation(evaluation, splitName, key, attributes) {\n    var _context7, _context8, _context9;\n\n    var stopLatencyTracker = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    var impressionsTracker = arguments.length > 5 ? arguments[5] : undefined;\n    var withConfig = arguments.length > 6 ? arguments[6] : undefined;\n    var invokingMethodName = arguments.length > 7 ? arguments[7] : undefined;\n    var isSdkReady = context.get(context.constants.READY, true) || context.get(context.constants.READY_FROM_CACHE, true);\n    var matchingKey = matching(key);\n    var bucketingKey = bucketing(key); // If the SDK was not ready, treatment may be incorrect due to having Splits but not segments data.\n\n    if (!isSdkReady) {\n      evaluation = {\n        treatment: CONTROL,\n        label: SDK_NOT_READY\n      };\n    }\n\n    var _evaluation = evaluation,\n        treatment = _evaluation.treatment,\n        label = _evaluation.label,\n        changeNumber = _evaluation.changeNumber,\n        _evaluation$config = _evaluation.config,\n        config = _evaluation$config === void 0 ? null : _evaluation$config;\n    log.info(_concatInstanceProperty(_context7 = _concatInstanceProperty(_context8 = _concatInstanceProperty(_context9 = \"Split: \".concat(splitName, \". Key: \")).call(_context9, matchingKey, \". Evaluation: \")).call(_context8, treatment, \". Label: \")).call(_context7, label));\n\n    if (validateSplitExistance(context, splitName, label, invokingMethodName)) {\n      log.info('Queueing corresponding impression.');\n      impressionsTracker({\n        feature: splitName,\n        keyName: matchingKey,\n        treatment: treatment,\n        time: _Date$now(),\n        bucketingKey: bucketingKey,\n        label: label,\n        changeNumber: changeNumber\n      }, attributes);\n    }\n\n    stopLatencyTracker && stopLatencyTracker();\n\n    if (withConfig) {\n      return {\n        treatment: treatment,\n        config: config\n      };\n    }\n\n    return treatment;\n  }\n\n  function track(key, trafficTypeName, eventTypeId) {\n    var value = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    var properties = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    var size = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1024;\n    var matchingKey = matching(key);\n\n    var timestamp = _Date$now();\n\n    var eventData = {\n      eventTypeId: eventTypeId,\n      trafficTypeName: trafficTypeName,\n      value: value,\n      timestamp: timestamp,\n      key: matchingKey,\n      properties: properties\n    }; // This may be async but we only warn, we don't actually care if it is valid or not in terms of queueing the event.\n\n    validateTrafficTypeExistance(trafficTypeName, context, 'track');\n    var tracked = storage.events.track(eventData, size);\n\n    if (thenable(tracked)) {\n      return tracked.then(_bindInstanceProperty(queueEventsCallback).call(queueEventsCallback, null, eventData));\n    } else {\n      return queueEventsCallback(eventData, tracked);\n    }\n  }\n\n  return {\n    getTreatment: getTreatment,\n    getTreatmentWithConfig: getTreatmentWithConfig,\n    getTreatments: getTreatments,\n    getTreatmentsWithConfig: getTreatmentsWithConfig,\n    track: track\n  };\n}\n\nexport default ClientFactory;"]},"metadata":{},"sourceType":"module"}