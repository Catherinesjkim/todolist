{"ast":null,"code":"import _forEachInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/for-each\";\nimport _Map from \"@babel/runtime-corejs3/core-js-stable/map\";\nimport _Number$isNaN from \"@babel/runtime-corejs3/core-js-stable/number/is-nan\";\nimport _parseInt from \"@babel/runtime-corejs3/core-js-stable/parse-int\";\nimport _slicedToArray from \"@babel/runtime-corejs3/helpers/esm/slicedToArray\";\nimport _getIterator from \"@babel/runtime-corejs3/core-js/get-iterator\";\nimport _keysInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/keys\";\nimport _classCallCheck from \"@babel/runtime-corejs3/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime-corejs3/helpers/esm/createClass\";\nimport { isFinite, toNumber } from '../../utils/lang';\nimport usesSegments from '../../utils/splits/usesSegments';\nimport logFactory from '../../utils/logger';\nvar log = logFactory('splitio-storage:localstorage');\n\nvar SplitCacheLocalStorage = /*#__PURE__*/function () {\n  function SplitCacheLocalStorage(keys) {\n    _classCallCheck(this, SplitCacheLocalStorage);\n\n    this.keys = keys;\n  }\n\n  _createClass(SplitCacheLocalStorage, [{\n    key: \"decrementCount\",\n    value: function decrementCount(key) {\n      var count = toNumber(localStorage.getItem(key)) - 1;\n      if (count > 0) localStorage.setItem(key, count);else localStorage.removeItem(key);\n    }\n  }, {\n    key: \"decrementCounts\",\n    value: function decrementCounts(split) {\n      try {\n        if (split) {\n          if (split.trafficTypeName) {\n            var ttKey = _keysInstanceProperty(this).buildTrafficTypeKey(split.trafficTypeName);\n\n            this.decrementCount(ttKey);\n          }\n\n          if (usesSegments(split.conditions)) {\n            var segmentsCountKey = _keysInstanceProperty(this).buildSplitsWithSegmentCountKey();\n\n            this.decrementCount(segmentsCountKey);\n          }\n        }\n      } catch (e) {\n        log.error(e);\n      }\n    }\n  }, {\n    key: \"incrementCounts\",\n    value: function incrementCounts(split) {\n      try {\n        if (split) {\n          if (split.trafficTypeName) {\n            var ttKey = _keysInstanceProperty(this).buildTrafficTypeKey(split.trafficTypeName);\n\n            localStorage.setItem(ttKey, toNumber(localStorage.getItem(ttKey)) + 1);\n          }\n\n          if (usesSegments(split.conditions)) {\n            var segmentsCountKey = _keysInstanceProperty(this).buildSplitsWithSegmentCountKey();\n\n            localStorage.setItem(segmentsCountKey, toNumber(localStorage.getItem(segmentsCountKey)) + 1);\n          }\n        }\n      } catch (e) {\n        log.error(e);\n      }\n    }\n  }, {\n    key: \"addSplit\",\n    value: function addSplit(splitName, split) {\n      try {\n        var splitKey = _keysInstanceProperty(this).buildSplitKey(splitName);\n\n        var splitFromLocalStorage = localStorage.getItem(splitKey);\n        var previousSplit = splitFromLocalStorage ? JSON.parse(splitFromLocalStorage) : null;\n        this.decrementCounts(previousSplit);\n        localStorage.setItem(splitKey, split);\n        var parsedSplit = split ? JSON.parse(split) : null;\n        this.incrementCounts(parsedSplit);\n        return true;\n      } catch (e) {\n        log.error(e);\n        return false;\n      }\n    }\n  }, {\n    key: \"addSplits\",\n    value: function addSplits(entries) {\n      var results = [];\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = _getIterator(entries), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var _step$value = _slicedToArray(_step.value, 2),\n              key = _step$value[0],\n              value = _step$value[1];\n\n          results.push(this.addSplit(key, value));\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return results;\n    }\n  }, {\n    key: \"removeSplit\",\n    value: function removeSplit(splitName) {\n      try {\n        var split = this.getSplit(splitName);\n        localStorage.removeItem(_keysInstanceProperty(this).buildSplitKey(splitName));\n        var parsedSplit = JSON.parse(split);\n        this.decrementCounts(parsedSplit);\n        return 1;\n      } catch (e) {\n        log.error(e);\n        return 0;\n      }\n    }\n    /**\n     * Bulk delete of splits from LocalStorage. Returns the number of deleted keys.\n     */\n\n  }, {\n    key: \"removeSplits\",\n    value: function removeSplits(names) {\n      var i = 0;\n      var len = names.length;\n      var counter = 0;\n\n      for (; i < len; i++) {\n        counter += this.removeSplit(names[i]);\n      }\n\n      return counter;\n    }\n  }, {\n    key: \"getSplit\",\n    value: function getSplit(splitName) {\n      return localStorage.getItem(_keysInstanceProperty(this).buildSplitKey(splitName));\n    }\n  }, {\n    key: \"setChangeNumber\",\n    value: function setChangeNumber(changeNumber) {\n      try {\n        localStorage.setItem(_keysInstanceProperty(this).buildSplitsTillKey(), changeNumber + '');\n        return true;\n      } catch (e) {\n        log.error(e);\n        return false;\n      }\n    }\n  }, {\n    key: \"getChangeNumber\",\n    value: function getChangeNumber() {\n      var n = -1;\n      var value = localStorage.getItem(_keysInstanceProperty(this).buildSplitsTillKey());\n\n      if (value !== null) {\n        value = _parseInt(value, 10);\n        return _Number$isNaN(value) ? n : value;\n      }\n\n      return n;\n    }\n  }, {\n    key: \"getAll\",\n    value: function getAll() {\n      var len = localStorage.length;\n      var accum = [];\n      var cur = 0;\n\n      while (cur < len) {\n        var key = localStorage.key(cur);\n        var value = key && localStorage.getItem(key);\n        if (key != null && _keysInstanceProperty(this).isSplitKey(key) && value) accum.push(value);\n        cur++;\n      }\n\n      return accum;\n    }\n  }, {\n    key: \"getKeys\",\n    value: function getKeys() {\n      var len = localStorage.length;\n      var accum = [];\n      var cur = 0;\n\n      while (cur < len) {\n        var key = localStorage.key(cur);\n        if (key != null && _keysInstanceProperty(this).isSplitKey(key)) accum.push(_keysInstanceProperty(this).extractKey(key));\n        cur++;\n      }\n\n      return accum;\n    }\n  }, {\n    key: \"trafficTypeExists\",\n    value: function trafficTypeExists(trafficType) {\n      var ttCount = toNumber(localStorage.getItem(_keysInstanceProperty(this).buildTrafficTypeKey(trafficType)));\n      return isFinite(ttCount) && ttCount > 0;\n    }\n  }, {\n    key: \"usesSegments\",\n    value: function usesSegments() {\n      // If there are no splits in the cache yet, assume we need them.\n      if (this.getChangeNumber() === -1) return true;\n      var storedCount = localStorage.getItem(_keysInstanceProperty(this).buildSplitsWithSegmentCountKey());\n      var splitsWithSegmentsCount = storedCount === null ? 0 : toNumber(storedCount);\n\n      if (isFinite(splitsWithSegmentsCount)) {\n        return splitsWithSegmentsCount > 0;\n      } else {\n        return true;\n      }\n    }\n  }, {\n    key: \"flush\",\n    value: function flush() {\n      log.info('Flushing localStorage');\n      localStorage.clear();\n    }\n    /**\n     * Fetches multiple splits definitions.\n     */\n\n  }, {\n    key: \"fetchMany\",\n    value: function fetchMany(splitNames) {\n      var _this = this;\n\n      var splits = new _Map();\n\n      _forEachInstanceProperty(splitNames).call(splitNames, function (splitName) {\n        splits.set(splitName, localStorage.getItem(_keysInstanceProperty(_this).buildSplitKey(splitName)));\n      });\n\n      return splits;\n    }\n    /**\n     * Check if the splits information is already stored in cache.\n     * In this function we could add more code to check if the data is valid.\n     */\n\n  }, {\n    key: \"checkCache\",\n    value: function checkCache() {\n      return this.getChangeNumber() > -1;\n    }\n  }]);\n\n  return SplitCacheLocalStorage;\n}();\n\nexport default SplitCacheLocalStorage;","map":{"version":3,"sources":["/Users/talianassi/node_modules/@splitsoftware/splitio/es/storage/SplitCache/InLocalStorage.js"],"names":["_forEachInstanceProperty","_Map","_Number$isNaN","_parseInt","_slicedToArray","_getIterator","_keysInstanceProperty","_classCallCheck","_createClass","isFinite","toNumber","usesSegments","logFactory","log","SplitCacheLocalStorage","keys","key","value","decrementCount","count","localStorage","getItem","setItem","removeItem","decrementCounts","split","trafficTypeName","ttKey","buildTrafficTypeKey","conditions","segmentsCountKey","buildSplitsWithSegmentCountKey","e","error","incrementCounts","addSplit","splitName","splitKey","buildSplitKey","splitFromLocalStorage","previousSplit","JSON","parse","parsedSplit","addSplits","entries","results","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_iterator","_step","next","done","_step$value","push","err","removeSplit","getSplit","removeSplits","names","i","len","length","counter","setChangeNumber","changeNumber","buildSplitsTillKey","getChangeNumber","n","getAll","accum","cur","isSplitKey","getKeys","extractKey","trafficTypeExists","trafficType","ttCount","storedCount","splitsWithSegmentsCount","flush","info","clear","fetchMany","splitNames","_this","splits","call","set","checkCache"],"mappings":"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","sourcesContent":["import _forEachInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/for-each\";\nimport _Map from \"@babel/runtime-corejs3/core-js-stable/map\";\nimport _Number$isNaN from \"@babel/runtime-corejs3/core-js-stable/number/is-nan\";\nimport _parseInt from \"@babel/runtime-corejs3/core-js-stable/parse-int\";\nimport _slicedToArray from \"@babel/runtime-corejs3/helpers/esm/slicedToArray\";\nimport _getIterator from \"@babel/runtime-corejs3/core-js/get-iterator\";\nimport _keysInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/keys\";\nimport _classCallCheck from \"@babel/runtime-corejs3/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime-corejs3/helpers/esm/createClass\";\nimport { isFinite, toNumber } from '../../utils/lang';\nimport usesSegments from '../../utils/splits/usesSegments';\nimport logFactory from '../../utils/logger';\nvar log = logFactory('splitio-storage:localstorage');\n\nvar SplitCacheLocalStorage =\n/*#__PURE__*/\nfunction () {\n  function SplitCacheLocalStorage(keys) {\n    _classCallCheck(this, SplitCacheLocalStorage);\n\n    this.keys = keys;\n  }\n\n  _createClass(SplitCacheLocalStorage, [{\n    key: \"decrementCount\",\n    value: function decrementCount(key) {\n      var count = toNumber(localStorage.getItem(key)) - 1;\n      if (count > 0) localStorage.setItem(key, count);else localStorage.removeItem(key);\n    }\n  }, {\n    key: \"decrementCounts\",\n    value: function decrementCounts(split) {\n      try {\n        if (split) {\n          if (split.trafficTypeName) {\n            var ttKey = _keysInstanceProperty(this).buildTrafficTypeKey(split.trafficTypeName);\n\n            this.decrementCount(ttKey);\n          }\n\n          if (usesSegments(split.conditions)) {\n            var segmentsCountKey = _keysInstanceProperty(this).buildSplitsWithSegmentCountKey();\n\n            this.decrementCount(segmentsCountKey);\n          }\n        }\n      } catch (e) {\n        log.error(e);\n      }\n    }\n  }, {\n    key: \"incrementCounts\",\n    value: function incrementCounts(split) {\n      try {\n        if (split) {\n          if (split.trafficTypeName) {\n            var ttKey = _keysInstanceProperty(this).buildTrafficTypeKey(split.trafficTypeName);\n\n            localStorage.setItem(ttKey, toNumber(localStorage.getItem(ttKey)) + 1);\n          }\n\n          if (usesSegments(split.conditions)) {\n            var segmentsCountKey = _keysInstanceProperty(this).buildSplitsWithSegmentCountKey();\n\n            localStorage.setItem(segmentsCountKey, toNumber(localStorage.getItem(segmentsCountKey)) + 1);\n          }\n        }\n      } catch (e) {\n        log.error(e);\n      }\n    }\n  }, {\n    key: \"addSplit\",\n    value: function addSplit(splitName, split) {\n      try {\n        var splitKey = _keysInstanceProperty(this).buildSplitKey(splitName);\n\n        var splitFromLocalStorage = localStorage.getItem(splitKey);\n        var previousSplit = splitFromLocalStorage ? JSON.parse(splitFromLocalStorage) : null;\n        this.decrementCounts(previousSplit);\n        localStorage.setItem(splitKey, split);\n        var parsedSplit = split ? JSON.parse(split) : null;\n        this.incrementCounts(parsedSplit);\n        return true;\n      } catch (e) {\n        log.error(e);\n        return false;\n      }\n    }\n  }, {\n    key: \"addSplits\",\n    value: function addSplits(entries) {\n      var results = [];\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = _getIterator(entries), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var _step$value = _slicedToArray(_step.value, 2),\n              key = _step$value[0],\n              value = _step$value[1];\n\n          results.push(this.addSplit(key, value));\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return results;\n    }\n  }, {\n    key: \"removeSplit\",\n    value: function removeSplit(splitName) {\n      try {\n        var split = this.getSplit(splitName);\n        localStorage.removeItem(_keysInstanceProperty(this).buildSplitKey(splitName));\n        var parsedSplit = JSON.parse(split);\n        this.decrementCounts(parsedSplit);\n        return 1;\n      } catch (e) {\n        log.error(e);\n        return 0;\n      }\n    }\n    /**\n     * Bulk delete of splits from LocalStorage. Returns the number of deleted keys.\n     */\n\n  }, {\n    key: \"removeSplits\",\n    value: function removeSplits(names) {\n      var i = 0;\n      var len = names.length;\n      var counter = 0;\n\n      for (; i < len; i++) {\n        counter += this.removeSplit(names[i]);\n      }\n\n      return counter;\n    }\n  }, {\n    key: \"getSplit\",\n    value: function getSplit(splitName) {\n      return localStorage.getItem(_keysInstanceProperty(this).buildSplitKey(splitName));\n    }\n  }, {\n    key: \"setChangeNumber\",\n    value: function setChangeNumber(changeNumber) {\n      try {\n        localStorage.setItem(_keysInstanceProperty(this).buildSplitsTillKey(), changeNumber + '');\n        return true;\n      } catch (e) {\n        log.error(e);\n        return false;\n      }\n    }\n  }, {\n    key: \"getChangeNumber\",\n    value: function getChangeNumber() {\n      var n = -1;\n      var value = localStorage.getItem(_keysInstanceProperty(this).buildSplitsTillKey());\n\n      if (value !== null) {\n        value = _parseInt(value, 10);\n        return _Number$isNaN(value) ? n : value;\n      }\n\n      return n;\n    }\n  }, {\n    key: \"getAll\",\n    value: function getAll() {\n      var len = localStorage.length;\n      var accum = [];\n      var cur = 0;\n\n      while (cur < len) {\n        var key = localStorage.key(cur);\n        var value = key && localStorage.getItem(key);\n        if (key != null && _keysInstanceProperty(this).isSplitKey(key) && value) accum.push(value);\n        cur++;\n      }\n\n      return accum;\n    }\n  }, {\n    key: \"getKeys\",\n    value: function getKeys() {\n      var len = localStorage.length;\n      var accum = [];\n      var cur = 0;\n\n      while (cur < len) {\n        var key = localStorage.key(cur);\n        if (key != null && _keysInstanceProperty(this).isSplitKey(key)) accum.push(_keysInstanceProperty(this).extractKey(key));\n        cur++;\n      }\n\n      return accum;\n    }\n  }, {\n    key: \"trafficTypeExists\",\n    value: function trafficTypeExists(trafficType) {\n      var ttCount = toNumber(localStorage.getItem(_keysInstanceProperty(this).buildTrafficTypeKey(trafficType)));\n      return isFinite(ttCount) && ttCount > 0;\n    }\n  }, {\n    key: \"usesSegments\",\n    value: function usesSegments() {\n      // If there are no splits in the cache yet, assume we need them.\n      if (this.getChangeNumber() === -1) return true;\n      var storedCount = localStorage.getItem(_keysInstanceProperty(this).buildSplitsWithSegmentCountKey());\n      var splitsWithSegmentsCount = storedCount === null ? 0 : toNumber(storedCount);\n\n      if (isFinite(splitsWithSegmentsCount)) {\n        return splitsWithSegmentsCount > 0;\n      } else {\n        return true;\n      }\n    }\n  }, {\n    key: \"flush\",\n    value: function flush() {\n      log.info('Flushing localStorage');\n      localStorage.clear();\n    }\n    /**\n     * Fetches multiple splits definitions.\n     */\n\n  }, {\n    key: \"fetchMany\",\n    value: function fetchMany(splitNames) {\n      var _this = this;\n\n      var splits = new _Map();\n\n      _forEachInstanceProperty(splitNames).call(splitNames, function (splitName) {\n        splits.set(splitName, localStorage.getItem(_keysInstanceProperty(_this).buildSplitKey(splitName)));\n      });\n\n      return splits;\n    }\n    /**\n     * Check if the splits information is already stored in cache.\n     * In this function we could add more code to check if the data is valid.\n     */\n\n  }, {\n    key: \"checkCache\",\n    value: function checkCache() {\n      return this.getChangeNumber() > -1;\n    }\n  }]);\n\n  return SplitCacheLocalStorage;\n}();\n\nexport default SplitCacheLocalStorage;"]},"metadata":{},"sourceType":"module"}