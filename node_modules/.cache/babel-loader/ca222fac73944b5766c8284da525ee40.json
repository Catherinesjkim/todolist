{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime-corejs3/regenerator\";\nimport _Promise from \"@babel/runtime-corejs3/core-js-stable/promise\";\nimport _asyncToGenerator from \"@babel/runtime-corejs3/helpers/esm/asyncToGenerator\";\nimport _Object$create from \"@babel/runtime-corejs3/core-js-stable/object/create\";\nimport _Object$assign from \"@babel/runtime-corejs3/core-js-stable/object/assign\";\nimport _setTimeout from \"@babel/runtime-corejs3/core-js-stable/set-timeout\";\nimport ClientFactory from '../client';\nimport FullProducerFactory from '../producer';\nimport PartialProducerFactory from '../producer/browser/Partial';\nimport MetricsFactory from '../metrics';\nimport EventsFactory from '../events';\nimport SignalsListener from '../listeners';\nimport { STANDALONE_MODE, PRODUCER_MODE, CONSUMER_MODE } from '../utils/constants';\nimport { releaseApiKey } from '../utils/inputValidation'; //\n// Create SDK instance based on the provided configurations\n//\n\nfunction SplitFactoryOnline(context, readyTrackers, mainClientMetricCollectors) {\n  var sharedInstance = !!mainClientMetricCollectors;\n  var settings = context.get(context.constants.SETTINGS);\n  var readiness = context.get(context.constants.READINESS);\n  var storage = context.get(context.constants.STORAGE);\n  var statusManager = context.get(context.constants.STATUS_MANAGER); // We are only interested in exposable EventEmitter\n\n  var gate = readiness.gate,\n      splits = readiness.splits,\n      segments = readiness.segments; // Events name\n\n  var SDK_READY = gate.SDK_READY; // Shared instances use parent metrics collectors\n\n  var metrics = sharedInstance ? undefined : MetricsFactory(context); // Shared instances use parent events queue\n\n  var events = sharedInstance ? undefined : EventsFactory(context); // Signal listener only needed for main instances\n\n  var signalsListener = sharedInstance ? undefined : new SignalsListener(context);\n  var producer;\n\n  switch (settings.mode) {\n    case PRODUCER_MODE:\n    case STANDALONE_MODE:\n      {\n        context.put(context.constants.COLLECTORS, metrics && metrics.collectors); // We don't fully instantiate producer if we are creating a shared instance.\n\n        producer = sharedInstance ? PartialProducerFactory(context) : FullProducerFactory(context);\n        break;\n      }\n\n    case CONSUMER_MODE:\n      {\n        context.put(context.constants.READY, true); // For SDK inner workings it's supposed to be ready.\n\n        _setTimeout(function () {\n          // Allow for the sync statements to run so client is returned before these are emitted and callbacks executed.\n          splits.emit(splits.SDK_SPLITS_ARRIVED, false);\n          segments.emit(segments.SDK_SEGMENTS_ARRIVED, false);\n        }, 0);\n\n        break;\n      }\n  }\n\n  if (readyTrackers && producer && !sharedInstance) {\n    // Only track ready events for non-shared and non-consumer clients\n    var sdkReadyTracker = readyTrackers.sdkReadyTracker,\n        splitsReadyTracker = readyTrackers.splitsReadyTracker,\n        segmentsReadyTracker = readyTrackers.segmentsReadyTracker; // Defered setup of collectors for this task, as it is the only ready latency we store on BE.\n\n    sdkReadyTracker.setCollectorForTask(metrics.collectors);\n    gate.on(SDK_READY, sdkReadyTracker);\n    splits.once(splits.SDK_SPLITS_ARRIVED, splitsReadyTracker);\n    segments.once(segments.SDK_SEGMENTS_ARRIVED, segmentsReadyTracker);\n  } // Start background jobs tasks\n\n\n  producer && producer.start();\n  metrics && metrics.start();\n  events && context.put(context.constants.EVENTS, events) && events.start(); // If no collectors are stored we are on a shared instance, save main one.\n\n  context.put(context.constants.COLLECTORS, mainClientMetricCollectors);\n\n  var api = _Object$assign( // Proto linkage of the EventEmitter to prevent any change\n  _Object$create(statusManager), // getTreatment/s & track\n  ClientFactory(context), // Utilities\n  {\n    // Destroy instance\n    destroy: function () {\n      var _destroy = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                // Stop background jobs\n                producer && producer.stop();\n                metrics && metrics.stop();\n                events && events.stop(); // Send impressions and events in parallel.\n\n                _context.next = 5;\n                return _Promise.all([metrics && metrics.flush(), events && events.flush()]);\n\n              case 5:\n                // Cleanup event listeners\n                readiness.destroy();\n                signalsListener && signalsListener.stop(); // Cleanup storage\n\n                storage.destroy && storage.destroy(); // Mark the factory as destroyed.\n\n                context.put(context.constants.DESTROYED, true); // And release the API Key\n\n                !sharedInstance && releaseApiKey(settings.core.authorizationKey);\n\n              case 10:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      function destroy() {\n        return _destroy.apply(this, arguments);\n      }\n\n      return destroy;\n    }()\n  }); // We'll start the signals listener if the client is not a shared instance.\n  // For now, we will only call destroy.\n\n\n  !sharedInstance && signalsListener.start(api.destroy);\n  return {\n    api: api,\n    metricCollectors: metrics && metrics.collectors\n  };\n}\n\nexport default SplitFactoryOnline;","map":{"version":3,"sources":["/Users/talianassi/Desktop/todolist/node_modules/@splitsoftware/splitio/es/factory/online.js"],"names":["_regeneratorRuntime","_Promise","_asyncToGenerator","_Object$create","_Object$assign","_setTimeout","ClientFactory","FullProducerFactory","PartialProducerFactory","MetricsFactory","EventsFactory","SignalsListener","STANDALONE_MODE","PRODUCER_MODE","CONSUMER_MODE","releaseApiKey","SplitFactoryOnline","context","readyTrackers","mainClientMetricCollectors","sharedInstance","settings","get","constants","SETTINGS","readiness","READINESS","storage","STORAGE","statusManager","STATUS_MANAGER","gate","splits","segments","SDK_READY","metrics","undefined","events","signalsListener","producer","mode","put","COLLECTORS","collectors","READY","emit","SDK_SPLITS_ARRIVED","SDK_SEGMENTS_ARRIVED","sdkReadyTracker","splitsReadyTracker","segmentsReadyTracker","setCollectorForTask","on","once","start","EVENTS","api","destroy","_destroy","mark","_callee","wrap","_callee$","_context","prev","next","stop","all","flush","DESTROYED","core","authorizationKey","apply","arguments","metricCollectors"],"mappings":"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","sourcesContent":["import _regeneratorRuntime from \"@babel/runtime-corejs3/regenerator\";\nimport _Promise from \"@babel/runtime-corejs3/core-js-stable/promise\";\nimport _asyncToGenerator from \"@babel/runtime-corejs3/helpers/esm/asyncToGenerator\";\nimport _Object$create from \"@babel/runtime-corejs3/core-js-stable/object/create\";\nimport _Object$assign from \"@babel/runtime-corejs3/core-js-stable/object/assign\";\nimport _setTimeout from \"@babel/runtime-corejs3/core-js-stable/set-timeout\";\nimport ClientFactory from '../client';\nimport FullProducerFactory from '../producer';\nimport PartialProducerFactory from '../producer/browser/Partial';\nimport MetricsFactory from '../metrics';\nimport EventsFactory from '../events';\nimport SignalsListener from '../listeners';\nimport { STANDALONE_MODE, PRODUCER_MODE, CONSUMER_MODE } from '../utils/constants';\nimport { releaseApiKey } from '../utils/inputValidation'; //\n// Create SDK instance based on the provided configurations\n//\n\nfunction SplitFactoryOnline(context, readyTrackers, mainClientMetricCollectors) {\n  var sharedInstance = !!mainClientMetricCollectors;\n  var settings = context.get(context.constants.SETTINGS);\n  var readiness = context.get(context.constants.READINESS);\n  var storage = context.get(context.constants.STORAGE);\n  var statusManager = context.get(context.constants.STATUS_MANAGER); // We are only interested in exposable EventEmitter\n\n  var gate = readiness.gate,\n      splits = readiness.splits,\n      segments = readiness.segments; // Events name\n\n  var SDK_READY = gate.SDK_READY; // Shared instances use parent metrics collectors\n\n  var metrics = sharedInstance ? undefined : MetricsFactory(context); // Shared instances use parent events queue\n\n  var events = sharedInstance ? undefined : EventsFactory(context); // Signal listener only needed for main instances\n\n  var signalsListener = sharedInstance ? undefined : new SignalsListener(context);\n  var producer;\n\n  switch (settings.mode) {\n    case PRODUCER_MODE:\n    case STANDALONE_MODE:\n      {\n        context.put(context.constants.COLLECTORS, metrics && metrics.collectors); // We don't fully instantiate producer if we are creating a shared instance.\n\n        producer = sharedInstance ? PartialProducerFactory(context) : FullProducerFactory(context);\n        break;\n      }\n\n    case CONSUMER_MODE:\n      {\n        context.put(context.constants.READY, true); // For SDK inner workings it's supposed to be ready.\n\n        _setTimeout(function () {\n          // Allow for the sync statements to run so client is returned before these are emitted and callbacks executed.\n          splits.emit(splits.SDK_SPLITS_ARRIVED, false);\n          segments.emit(segments.SDK_SEGMENTS_ARRIVED, false);\n        }, 0);\n\n        break;\n      }\n  }\n\n  if (readyTrackers && producer && !sharedInstance) {\n    // Only track ready events for non-shared and non-consumer clients\n    var sdkReadyTracker = readyTrackers.sdkReadyTracker,\n        splitsReadyTracker = readyTrackers.splitsReadyTracker,\n        segmentsReadyTracker = readyTrackers.segmentsReadyTracker; // Defered setup of collectors for this task, as it is the only ready latency we store on BE.\n\n    sdkReadyTracker.setCollectorForTask(metrics.collectors);\n    gate.on(SDK_READY, sdkReadyTracker);\n    splits.once(splits.SDK_SPLITS_ARRIVED, splitsReadyTracker);\n    segments.once(segments.SDK_SEGMENTS_ARRIVED, segmentsReadyTracker);\n  } // Start background jobs tasks\n\n\n  producer && producer.start();\n  metrics && metrics.start();\n  events && context.put(context.constants.EVENTS, events) && events.start(); // If no collectors are stored we are on a shared instance, save main one.\n\n  context.put(context.constants.COLLECTORS, mainClientMetricCollectors);\n\n  var api = _Object$assign( // Proto linkage of the EventEmitter to prevent any change\n  _Object$create(statusManager), // getTreatment/s & track\n  ClientFactory(context), // Utilities\n  {\n    // Destroy instance\n    destroy: function () {\n      var _destroy = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                // Stop background jobs\n                producer && producer.stop();\n                metrics && metrics.stop();\n                events && events.stop(); // Send impressions and events in parallel.\n\n                _context.next = 5;\n                return _Promise.all([metrics && metrics.flush(), events && events.flush()]);\n\n              case 5:\n                // Cleanup event listeners\n                readiness.destroy();\n                signalsListener && signalsListener.stop(); // Cleanup storage\n\n                storage.destroy && storage.destroy(); // Mark the factory as destroyed.\n\n                context.put(context.constants.DESTROYED, true); // And release the API Key\n\n                !sharedInstance && releaseApiKey(settings.core.authorizationKey);\n\n              case 10:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      function destroy() {\n        return _destroy.apply(this, arguments);\n      }\n\n      return destroy;\n    }()\n  }); // We'll start the signals listener if the client is not a shared instance.\n  // For now, we will only call destroy.\n\n\n  !sharedInstance && signalsListener.start(api.destroy);\n  return {\n    api: api,\n    metricCollectors: metrics && metrics.collectors\n  };\n}\n\nexport default SplitFactoryOnline;"]},"metadata":{},"sourceType":"module"}