{"ast":null,"code":"import _getIterator from \"@babel/runtime-corejs3/core-js/get-iterator\";\nimport _keysInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/keys\";\nimport _Map from \"@babel/runtime-corejs3/core-js-stable/map\";\nimport _classCallCheck from \"@babel/runtime-corejs3/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime-corejs3/helpers/esm/createClass\";\n\nvar SegmentCacheInMemory = /*#__PURE__*/function () {\n  function SegmentCacheInMemory(keys) {\n    _classCallCheck(this, SegmentCacheInMemory);\n\n    this.keys = keys;\n    this.flush();\n  }\n\n  _createClass(SegmentCacheInMemory, [{\n    key: \"flush\",\n    value: function flush() {\n      this.segmentCache = new _Map();\n    }\n  }, {\n    key: \"addToSegment\",\n    value: function addToSegment(segmentName\n    /*, segmentKeys: Array<string>*/\n    ) {\n      var segmentKey = _keysInstanceProperty(this).buildSegmentNameKey(segmentName);\n\n      this.segmentCache.set(segmentKey, true);\n      return true;\n    }\n  }, {\n    key: \"removeFromSegment\",\n    value: function removeFromSegment(segmentName\n    /*, segmentKeys: Array<string>*/\n    ) {\n      var segmentKey = _keysInstanceProperty(this).buildSegmentNameKey(segmentName);\n\n      this.segmentCache[\"delete\"](segmentKey);\n      return true;\n    } // @NOTE based on the way we use segments in the browser, this way is the best\n    //       option\n\n  }, {\n    key: \"resetSegments\",\n    value: function resetSegments(segmentNames) {\n      var isDiff = false;\n      var index;\n      var s; // Extreme fast => everything is empty\n\n      if (segmentNames.length === 0 && this.segmentCache.size === segmentNames.length) return isDiff; // Quick path\n\n      if (this.segmentCache.size !== segmentNames.length) {\n        isDiff = true;\n        this.segmentCache = new _Map();\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = _getIterator(segmentNames), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            s = _step.value;\n            this.addToSegment(s);\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n              _iterator[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      } else {\n        // Slowest path => we need to find at least 1 difference because\n        for (index = 0; index < segmentNames.length && this.isInSegment(segmentNames[index]); index++) {// TODO: why empty statement?\n        }\n\n        if (index < segmentNames.length) {\n          isDiff = true;\n          this.segmentCache = new _Map();\n          var _iteratorNormalCompletion2 = true;\n          var _didIteratorError2 = false;\n          var _iteratorError2 = undefined;\n\n          try {\n            for (var _iterator2 = _getIterator(segmentNames), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n              s = _step2.value;\n              this.addToSegment(s);\n            }\n          } catch (err) {\n            _didIteratorError2 = true;\n            _iteratorError2 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n                _iterator2[\"return\"]();\n              }\n            } finally {\n              if (_didIteratorError2) {\n                throw _iteratorError2;\n              }\n            }\n          }\n        }\n      }\n\n      return isDiff;\n    }\n  }, {\n    key: \"isInSegment\",\n    value: function isInSegment(segmentName\n    /*, key: string*/\n    ) {\n      var segmentKey = _keysInstanceProperty(this).buildSegmentNameKey(segmentName);\n\n      return this.segmentCache.get(segmentKey) === true;\n    }\n  }, {\n    key: \"setChangeNumber\",\n    value: function setChangeNumber()\n    /*segmentName: string, changeNumber: number*/\n    {\n      return true;\n    }\n  }, {\n    key: \"getChangeNumber\",\n    value: function getChangeNumber()\n    /*segmentName: string*/\n    {\n      return -1;\n    }\n  }, {\n    key: \"registerSegment\",\n    value: function registerSegment()\n    /*segment: string*/\n    {\n      return false;\n    }\n  }, {\n    key: \"registerSegments\",\n    value: function registerSegments()\n    /*segments: Iterable<string>*/\n    {\n      return false;\n    }\n  }, {\n    key: \"getRegisteredSegments\",\n    value: function getRegisteredSegments() {\n      return [];\n    }\n  }]);\n\n  return SegmentCacheInMemory;\n}();\n\nexport default SegmentCacheInMemory;","map":{"version":3,"sources":["/Users/talianassi/node_modules/@splitsoftware/splitio/es/storage/SegmentCache/InMemory/browser.js"],"names":["_getIterator","_keysInstanceProperty","_Map","_classCallCheck","_createClass","SegmentCacheInMemory","keys","flush","key","value","segmentCache","addToSegment","segmentName","segmentKey","buildSegmentNameKey","set","removeFromSegment","resetSegments","segmentNames","isDiff","index","s","length","size","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_iterator","_step","next","done","err","isInSegment","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_iterator2","_step2","get","setChangeNumber","getChangeNumber","registerSegment","registerSegments","getRegisteredSegments"],"mappings":"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","sourcesContent":["import _getIterator from \"@babel/runtime-corejs3/core-js/get-iterator\";\nimport _keysInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/keys\";\nimport _Map from \"@babel/runtime-corejs3/core-js-stable/map\";\nimport _classCallCheck from \"@babel/runtime-corejs3/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime-corejs3/helpers/esm/createClass\";\n\nvar SegmentCacheInMemory =\n/*#__PURE__*/\nfunction () {\n  function SegmentCacheInMemory(keys) {\n    _classCallCheck(this, SegmentCacheInMemory);\n\n    this.keys = keys;\n    this.flush();\n  }\n\n  _createClass(SegmentCacheInMemory, [{\n    key: \"flush\",\n    value: function flush() {\n      this.segmentCache = new _Map();\n    }\n  }, {\n    key: \"addToSegment\",\n    value: function addToSegment(segmentName\n    /*, segmentKeys: Array<string>*/\n    ) {\n      var segmentKey = _keysInstanceProperty(this).buildSegmentNameKey(segmentName);\n\n      this.segmentCache.set(segmentKey, true);\n      return true;\n    }\n  }, {\n    key: \"removeFromSegment\",\n    value: function removeFromSegment(segmentName\n    /*, segmentKeys: Array<string>*/\n    ) {\n      var segmentKey = _keysInstanceProperty(this).buildSegmentNameKey(segmentName);\n\n      this.segmentCache[\"delete\"](segmentKey);\n      return true;\n    } // @NOTE based on the way we use segments in the browser, this way is the best\n    //       option\n\n  }, {\n    key: \"resetSegments\",\n    value: function resetSegments(segmentNames) {\n      var isDiff = false;\n      var index;\n      var s; // Extreme fast => everything is empty\n\n      if (segmentNames.length === 0 && this.segmentCache.size === segmentNames.length) return isDiff; // Quick path\n\n      if (this.segmentCache.size !== segmentNames.length) {\n        isDiff = true;\n        this.segmentCache = new _Map();\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = _getIterator(segmentNames), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            s = _step.value;\n            this.addToSegment(s);\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n              _iterator[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      } else {\n        // Slowest path => we need to find at least 1 difference because\n        for (index = 0; index < segmentNames.length && this.isInSegment(segmentNames[index]); index++) {// TODO: why empty statement?\n        }\n\n        if (index < segmentNames.length) {\n          isDiff = true;\n          this.segmentCache = new _Map();\n          var _iteratorNormalCompletion2 = true;\n          var _didIteratorError2 = false;\n          var _iteratorError2 = undefined;\n\n          try {\n            for (var _iterator2 = _getIterator(segmentNames), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n              s = _step2.value;\n              this.addToSegment(s);\n            }\n          } catch (err) {\n            _didIteratorError2 = true;\n            _iteratorError2 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n                _iterator2[\"return\"]();\n              }\n            } finally {\n              if (_didIteratorError2) {\n                throw _iteratorError2;\n              }\n            }\n          }\n        }\n      }\n\n      return isDiff;\n    }\n  }, {\n    key: \"isInSegment\",\n    value: function isInSegment(segmentName\n    /*, key: string*/\n    ) {\n      var segmentKey = _keysInstanceProperty(this).buildSegmentNameKey(segmentName);\n\n      return this.segmentCache.get(segmentKey) === true;\n    }\n  }, {\n    key: \"setChangeNumber\",\n    value: function setChangeNumber()\n    /*segmentName: string, changeNumber: number*/\n    {\n      return true;\n    }\n  }, {\n    key: \"getChangeNumber\",\n    value: function getChangeNumber()\n    /*segmentName: string*/\n    {\n      return -1;\n    }\n  }, {\n    key: \"registerSegment\",\n    value: function registerSegment()\n    /*segment: string*/\n    {\n      return false;\n    }\n  }, {\n    key: \"registerSegments\",\n    value: function registerSegments()\n    /*segments: Iterable<string>*/\n    {\n      return false;\n    }\n  }, {\n    key: \"getRegisteredSegments\",\n    value: function getRegisteredSegments() {\n      return [];\n    }\n  }]);\n\n  return SegmentCacheInMemory;\n}();\n\nexport default SegmentCacheInMemory;"]},"metadata":{},"sourceType":"module"}