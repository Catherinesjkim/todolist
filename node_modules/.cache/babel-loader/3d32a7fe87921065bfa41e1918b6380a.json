{"ast":null,"code":"import _forEachInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/for-each\";\nimport _Object$assign from \"@babel/runtime-corejs3/core-js-stable/object/assign\";\nimport _Promise from \"@babel/runtime-corejs3/core-js-stable/promise\";\nimport ClientFactory from './client';\nimport { validateAttributes, validateEvent, validateEventValue, validateEventProperties, validateKey, validateSplit, validateSplits, validateTrafficType, validateIfDestroyed, validateIfReady } from '../utils/inputValidation';\nimport { startsWith } from '../utils/lang';\nimport { STORAGE_REDIS, CONTROL, CONTROL_WITH_CONFIG } from '../utils/constants';\n/**\n * We will validate the input before actually executing the client methods. We should \"guard\" the client here,\n * while not polluting the \"real\" implementation of those methods.\n */\n\nfunction ClientInputValidationLayer(context, isKeyBinded, isTTBinded) {\n  var settings = context.get(context.constants.SETTINGS);\n  var isStorageSync = settings.storage.type !== STORAGE_REDIS; // instantiate the client\n\n  var client = ClientFactory(context); // Keep a reference to the original methods\n\n  var clientGetTreatment = client.getTreatment;\n  var clientGetTreatmentWithConfig = client.getTreatmentWithConfig;\n  var clientGetTreatments = client.getTreatments;\n  var clientGetTreatmentsWithConfig = client.getTreatmentsWithConfig;\n  var clientTrack = client.track;\n  /**\n   * Avoid repeating this validations code\n   */\n\n  function validateEvaluationParams(maybeKey, maybeSplitOrSplits, maybeAttributes, methodName) {\n    var multi = startsWith(methodName, 'getTreatments');\n    var key = isKeyBinded ? maybeKey : validateKey(maybeKey, methodName);\n    var splitOrSplits = multi ? validateSplits(maybeSplitOrSplits, methodName) : validateSplit(maybeSplitOrSplits, methodName);\n    var attributes = validateAttributes(maybeAttributes, methodName);\n    var isOperational = validateIfDestroyed(context);\n    validateIfReady(context, methodName);\n    var valid = isOperational && key && splitOrSplits && attributes !== false;\n    return {\n      valid: valid,\n      key: key,\n      splitOrSplits: splitOrSplits,\n      attributes: attributes\n    };\n  }\n\n  client.getTreatment = function getTreatment(maybeKey, maybeSplit, maybeAttributes) {\n    var params = validateEvaluationParams(maybeKey, maybeSplit, maybeAttributes, 'getTreatment');\n\n    if (params.valid) {\n      return clientGetTreatment(params.key, params.splitOrSplits, params.attributes);\n    } else {\n      if (isStorageSync) return CONTROL;\n      return _Promise.resolve(CONTROL);\n    }\n  };\n\n  client.getTreatmentWithConfig = function getTreatmentWithConfig(maybeKey, maybeSplit, maybeAttributes) {\n    var params = validateEvaluationParams(maybeKey, maybeSplit, maybeAttributes, 'getTreatmentWithConfig');\n\n    if (params.valid) {\n      return clientGetTreatmentWithConfig(params.key, params.splitOrSplits, params.attributes);\n    } else {\n      if (isStorageSync) return _Object$assign({}, CONTROL_WITH_CONFIG);\n      return _Promise.resolve(_Object$assign({}, CONTROL_WITH_CONFIG));\n    }\n  };\n\n  client.getTreatments = function getTreatments(maybeKey, maybeSplits, maybeAttributes) {\n    var params = validateEvaluationParams(maybeKey, maybeSplits, maybeAttributes, 'getTreatments');\n\n    if (params.valid) {\n      return clientGetTreatments(params.key, params.splitOrSplits, params.attributes);\n    } else {\n      var _context;\n\n      var res = {};\n      if (params.splitOrSplits) _forEachInstanceProperty(_context = params.splitOrSplits).call(_context, function (split) {\n        return res[split] = CONTROL;\n      });\n      if (isStorageSync) return res;\n      return _Promise.resolve(res);\n    }\n  };\n\n  client.getTreatmentsWithConfig = function getTreatmentsWithConfig(maybeKey, maybeSplits, maybeAttributes) {\n    var params = validateEvaluationParams(maybeKey, maybeSplits, maybeAttributes, 'getTreatmentsWithConfig');\n\n    if (params.valid) {\n      return clientGetTreatmentsWithConfig(params.key, params.splitOrSplits, params.attributes);\n    } else {\n      var _context2;\n\n      var res = {};\n      if (params.splitOrSplits) _forEachInstanceProperty(_context2 = params.splitOrSplits).call(_context2, function (split) {\n        return res[split] = _Object$assign({}, CONTROL_WITH_CONFIG);\n      });\n      if (isStorageSync) return res;\n      return _Promise.resolve(res);\n    }\n  };\n\n  client.track = function track(maybeKey, maybeTT, maybeEvent, maybeEventValue, maybeProperties) {\n    var key = isKeyBinded ? maybeKey : validateKey(maybeKey, 'track');\n    var tt = isTTBinded ? maybeTT : validateTrafficType(maybeTT, 'track');\n    var event = validateEvent(maybeEvent, 'track');\n    var eventValue = validateEventValue(maybeEventValue, 'track');\n\n    var _validateEventPropert = validateEventProperties(maybeProperties),\n        properties = _validateEventPropert.properties,\n        size = _validateEventPropert.size;\n\n    var isOperational = validateIfDestroyed(context);\n\n    if (isOperational && key && tt && event && eventValue !== false && properties !== false) {\n      return clientTrack(key, tt, event, eventValue, properties, size);\n    } else {\n      if (isStorageSync) return false;\n      return _Promise.resolve(false);\n    }\n  };\n\n  return client;\n}\n\nexport default ClientInputValidationLayer;","map":{"version":3,"sources":["/Users/talianassi/node_modules/@splitsoftware/splitio/es/client/inputValidation.js"],"names":["_forEachInstanceProperty","_Object$assign","_Promise","ClientFactory","validateAttributes","validateEvent","validateEventValue","validateEventProperties","validateKey","validateSplit","validateSplits","validateTrafficType","validateIfDestroyed","validateIfReady","startsWith","STORAGE_REDIS","CONTROL","CONTROL_WITH_CONFIG","ClientInputValidationLayer","context","isKeyBinded","isTTBinded","settings","get","constants","SETTINGS","isStorageSync","storage","type","client","clientGetTreatment","getTreatment","clientGetTreatmentWithConfig","getTreatmentWithConfig","clientGetTreatments","getTreatments","clientGetTreatmentsWithConfig","getTreatmentsWithConfig","clientTrack","track","validateEvaluationParams","maybeKey","maybeSplitOrSplits","maybeAttributes","methodName","multi","key","splitOrSplits","attributes","isOperational","valid","maybeSplit","params","resolve","maybeSplits","_context","res","call","split","_context2","maybeTT","maybeEvent","maybeEventValue","maybeProperties","tt","event","eventValue","_validateEventPropert","properties","size"],"mappings":"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","sourcesContent":["import _forEachInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/for-each\";\nimport _Object$assign from \"@babel/runtime-corejs3/core-js-stable/object/assign\";\nimport _Promise from \"@babel/runtime-corejs3/core-js-stable/promise\";\nimport ClientFactory from './client';\nimport { validateAttributes, validateEvent, validateEventValue, validateEventProperties, validateKey, validateSplit, validateSplits, validateTrafficType, validateIfDestroyed, validateIfReady } from '../utils/inputValidation';\nimport { startsWith } from '../utils/lang';\nimport { STORAGE_REDIS, CONTROL, CONTROL_WITH_CONFIG } from '../utils/constants';\n/**\n * We will validate the input before actually executing the client methods. We should \"guard\" the client here,\n * while not polluting the \"real\" implementation of those methods.\n */\n\nfunction ClientInputValidationLayer(context, isKeyBinded, isTTBinded) {\n  var settings = context.get(context.constants.SETTINGS);\n  var isStorageSync = settings.storage.type !== STORAGE_REDIS; // instantiate the client\n\n  var client = ClientFactory(context); // Keep a reference to the original methods\n\n  var clientGetTreatment = client.getTreatment;\n  var clientGetTreatmentWithConfig = client.getTreatmentWithConfig;\n  var clientGetTreatments = client.getTreatments;\n  var clientGetTreatmentsWithConfig = client.getTreatmentsWithConfig;\n  var clientTrack = client.track;\n  /**\n   * Avoid repeating this validations code\n   */\n\n  function validateEvaluationParams(maybeKey, maybeSplitOrSplits, maybeAttributes, methodName) {\n    var multi = startsWith(methodName, 'getTreatments');\n    var key = isKeyBinded ? maybeKey : validateKey(maybeKey, methodName);\n    var splitOrSplits = multi ? validateSplits(maybeSplitOrSplits, methodName) : validateSplit(maybeSplitOrSplits, methodName);\n    var attributes = validateAttributes(maybeAttributes, methodName);\n    var isOperational = validateIfDestroyed(context);\n    validateIfReady(context, methodName);\n    var valid = isOperational && key && splitOrSplits && attributes !== false;\n    return {\n      valid: valid,\n      key: key,\n      splitOrSplits: splitOrSplits,\n      attributes: attributes\n    };\n  }\n\n  client.getTreatment = function getTreatment(maybeKey, maybeSplit, maybeAttributes) {\n    var params = validateEvaluationParams(maybeKey, maybeSplit, maybeAttributes, 'getTreatment');\n\n    if (params.valid) {\n      return clientGetTreatment(params.key, params.splitOrSplits, params.attributes);\n    } else {\n      if (isStorageSync) return CONTROL;\n      return _Promise.resolve(CONTROL);\n    }\n  };\n\n  client.getTreatmentWithConfig = function getTreatmentWithConfig(maybeKey, maybeSplit, maybeAttributes) {\n    var params = validateEvaluationParams(maybeKey, maybeSplit, maybeAttributes, 'getTreatmentWithConfig');\n\n    if (params.valid) {\n      return clientGetTreatmentWithConfig(params.key, params.splitOrSplits, params.attributes);\n    } else {\n      if (isStorageSync) return _Object$assign({}, CONTROL_WITH_CONFIG);\n      return _Promise.resolve(_Object$assign({}, CONTROL_WITH_CONFIG));\n    }\n  };\n\n  client.getTreatments = function getTreatments(maybeKey, maybeSplits, maybeAttributes) {\n    var params = validateEvaluationParams(maybeKey, maybeSplits, maybeAttributes, 'getTreatments');\n\n    if (params.valid) {\n      return clientGetTreatments(params.key, params.splitOrSplits, params.attributes);\n    } else {\n      var _context;\n\n      var res = {};\n      if (params.splitOrSplits) _forEachInstanceProperty(_context = params.splitOrSplits).call(_context, function (split) {\n        return res[split] = CONTROL;\n      });\n      if (isStorageSync) return res;\n      return _Promise.resolve(res);\n    }\n  };\n\n  client.getTreatmentsWithConfig = function getTreatmentsWithConfig(maybeKey, maybeSplits, maybeAttributes) {\n    var params = validateEvaluationParams(maybeKey, maybeSplits, maybeAttributes, 'getTreatmentsWithConfig');\n\n    if (params.valid) {\n      return clientGetTreatmentsWithConfig(params.key, params.splitOrSplits, params.attributes);\n    } else {\n      var _context2;\n\n      var res = {};\n      if (params.splitOrSplits) _forEachInstanceProperty(_context2 = params.splitOrSplits).call(_context2, function (split) {\n        return res[split] = _Object$assign({}, CONTROL_WITH_CONFIG);\n      });\n      if (isStorageSync) return res;\n      return _Promise.resolve(res);\n    }\n  };\n\n  client.track = function track(maybeKey, maybeTT, maybeEvent, maybeEventValue, maybeProperties) {\n    var key = isKeyBinded ? maybeKey : validateKey(maybeKey, 'track');\n    var tt = isTTBinded ? maybeTT : validateTrafficType(maybeTT, 'track');\n    var event = validateEvent(maybeEvent, 'track');\n    var eventValue = validateEventValue(maybeEventValue, 'track');\n\n    var _validateEventPropert = validateEventProperties(maybeProperties),\n        properties = _validateEventPropert.properties,\n        size = _validateEventPropert.size;\n\n    var isOperational = validateIfDestroyed(context);\n\n    if (isOperational && key && tt && event && eventValue !== false && properties !== false) {\n      return clientTrack(key, tt, event, eventValue, properties, size);\n    } else {\n      if (isStorageSync) return false;\n      return _Promise.resolve(false);\n    }\n  };\n\n  return client;\n}\n\nexport default ClientInputValidationLayer;"]},"metadata":{},"sourceType":"module"}