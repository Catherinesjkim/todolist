{"ast":null,"code":"import _Map from \"@babel/runtime-corejs3/core-js-stable/map\";\nimport _keysInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/keys\";\nimport _valuesInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/values\";\nimport _toConsumableArray from \"@babel/runtime-corejs3/helpers/esm/toConsumableArray\";\nimport _forEachInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/for-each\";\nimport _slicedToArray from \"@babel/runtime-corejs3/helpers/esm/slicedToArray\";\nimport _getIterator from \"@babel/runtime-corejs3/core-js/get-iterator\";\nimport _classCallCheck from \"@babel/runtime-corejs3/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime-corejs3/helpers/esm/createClass\";\nimport { isFinite } from '../../utils/lang';\nimport usesSegments from '../../utils/splits/usesSegments';\n\nvar SplitCacheInMemory = /*#__PURE__*/function () {\n  function SplitCacheInMemory() {\n    _classCallCheck(this, SplitCacheInMemory);\n\n    this.flush();\n  }\n\n  _createClass(SplitCacheInMemory, [{\n    key: \"addSplit\",\n    value: function addSplit(splitName, split) {\n      var splitFromMemory = this.getSplit(splitName);\n\n      if (splitFromMemory) {\n        // We had this Split already\n        var previousSplit = JSON.parse(splitFromMemory);\n\n        if (previousSplit.trafficTypeName) {\n          var previousTtName = previousSplit.trafficTypeName;\n          this.ttCache[previousTtName]--;\n          if (!this.ttCache[previousTtName]) delete this.ttCache[previousTtName];\n        }\n\n        if (usesSegments(previousSplit.conditions)) {\n          // Substract from segments count for the previous version of this Split.\n          this.splitsWithSegmentsCount--;\n        }\n      }\n\n      var parsedSplit = JSON.parse(split);\n\n      if (parsedSplit) {\n        // Store the Split.\n        this.splitCache.set(splitName, split); // Update TT cache\n\n        var ttName = parsedSplit.trafficTypeName;\n\n        if (ttName) {\n          // safeguard\n          if (!this.ttCache[ttName]) this.ttCache[ttName] = 0;\n          this.ttCache[ttName]++;\n        } // Add to segments count for the new version of the Split\n\n\n        if (usesSegments(parsedSplit.conditions)) this.splitsWithSegmentsCount++;\n        return true;\n      } else {\n        return false;\n      }\n    }\n  }, {\n    key: \"addSplits\",\n    value: function addSplits(entries) {\n      var results = [];\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = _getIterator(entries), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var _step$value = _slicedToArray(_step.value, 2),\n              key = _step$value[0],\n              value = _step$value[1];\n\n          results.push(this.addSplit(key, value));\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return results;\n    }\n  }, {\n    key: \"removeSplit\",\n    value: function removeSplit(splitName) {\n      var split = this.getSplit(splitName);\n\n      if (split) {\n        // Delete the Split\n        this.splitCache[\"delete\"](splitName);\n        var parsedSplit = JSON.parse(split);\n        var ttName = parsedSplit.trafficTypeName;\n\n        if (ttName) {\n          // safeguard\n          this.ttCache[ttName]--; // Update tt cache\n\n          if (!this.ttCache[ttName]) delete this.ttCache[ttName];\n        } // Update the segments count.\n\n\n        if (usesSegments(parsedSplit.conditions)) this.splitsWithSegmentsCount--;\n        return 1;\n      } else {\n        return 0;\n      }\n    }\n  }, {\n    key: \"removeSplits\",\n    value: function removeSplits(splitNames) {\n      var _this = this;\n\n      _forEachInstanceProperty(splitNames).call(splitNames, function (n) {\n        return _this.removeSplit(n);\n      });\n\n      return splitNames.length;\n    }\n  }, {\n    key: \"getSplit\",\n    value: function getSplit(splitName) {\n      return this.splitCache.get(splitName);\n    }\n  }, {\n    key: \"setChangeNumber\",\n    value: function setChangeNumber(changeNumber) {\n      this.changeNumber = changeNumber;\n      return true;\n    }\n  }, {\n    key: \"getChangeNumber\",\n    value: function getChangeNumber() {\n      return this.changeNumber;\n    }\n  }, {\n    key: \"getAll\",\n    value: function getAll() {\n      var _context;\n\n      return _toConsumableArray(_valuesInstanceProperty(_context = this.splitCache).call(_context));\n    }\n  }, {\n    key: \"getKeys\",\n    value: function getKeys() {\n      var _context2;\n\n      return _toConsumableArray(_keysInstanceProperty(_context2 = this.splitCache).call(_context2));\n    }\n  }, {\n    key: \"trafficTypeExists\",\n    value: function trafficTypeExists(trafficType) {\n      return isFinite(this.ttCache[trafficType]) && this.ttCache[trafficType] > 0;\n    }\n  }, {\n    key: \"usesSegments\",\n    value: function usesSegments() {\n      return this.getChangeNumber() === -1 || this.splitsWithSegmentsCount > 0;\n    }\n  }, {\n    key: \"flush\",\n    value: function flush() {\n      this.splitCache = new _Map();\n      this.ttCache = {};\n      this.changeNumber = -1;\n      this.splitsWithSegmentsCount = 0;\n    }\n    /**\n     * Fetches multiple splits definitions.\n     */\n\n  }, {\n    key: \"fetchMany\",\n    value: function fetchMany(splitNames) {\n      var _this2 = this;\n\n      var splits = new _Map();\n\n      _forEachInstanceProperty(splitNames).call(splitNames, function (splitName) {\n        splits.set(splitName, _this2.splitCache.get(splitName) || null);\n      });\n\n      return splits;\n    }\n    /**\n     * Check if the splits information is already stored in cache. In memory there is no cache to check.\n     */\n\n  }, {\n    key: \"checkCache\",\n    value: function checkCache() {\n      return false;\n    }\n  }]);\n\n  return SplitCacheInMemory;\n}();\n\nexport default SplitCacheInMemory;","map":{"version":3,"sources":["/Users/talianassi/Desktop/todolist/node_modules/@splitsoftware/splitio/es/storage/SplitCache/InMemory.js"],"names":["_Map","_keysInstanceProperty","_valuesInstanceProperty","_toConsumableArray","_forEachInstanceProperty","_slicedToArray","_getIterator","_classCallCheck","_createClass","isFinite","usesSegments","SplitCacheInMemory","flush","key","value","addSplit","splitName","split","splitFromMemory","getSplit","previousSplit","JSON","parse","trafficTypeName","previousTtName","ttCache","conditions","splitsWithSegmentsCount","parsedSplit","splitCache","set","ttName","addSplits","entries","results","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_iterator","_step","next","done","_step$value","push","err","removeSplit","removeSplits","splitNames","_this","call","n","length","get","setChangeNumber","changeNumber","getChangeNumber","getAll","_context","getKeys","_context2","trafficTypeExists","trafficType","fetchMany","_this2","splits","checkCache"],"mappings":"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","sourcesContent":["import _Map from \"@babel/runtime-corejs3/core-js-stable/map\";\nimport _keysInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/keys\";\nimport _valuesInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/values\";\nimport _toConsumableArray from \"@babel/runtime-corejs3/helpers/esm/toConsumableArray\";\nimport _forEachInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/for-each\";\nimport _slicedToArray from \"@babel/runtime-corejs3/helpers/esm/slicedToArray\";\nimport _getIterator from \"@babel/runtime-corejs3/core-js/get-iterator\";\nimport _classCallCheck from \"@babel/runtime-corejs3/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime-corejs3/helpers/esm/createClass\";\nimport { isFinite } from '../../utils/lang';\nimport usesSegments from '../../utils/splits/usesSegments';\n\nvar SplitCacheInMemory =\n/*#__PURE__*/\nfunction () {\n  function SplitCacheInMemory() {\n    _classCallCheck(this, SplitCacheInMemory);\n\n    this.flush();\n  }\n\n  _createClass(SplitCacheInMemory, [{\n    key: \"addSplit\",\n    value: function addSplit(splitName, split) {\n      var splitFromMemory = this.getSplit(splitName);\n\n      if (splitFromMemory) {\n        // We had this Split already\n        var previousSplit = JSON.parse(splitFromMemory);\n\n        if (previousSplit.trafficTypeName) {\n          var previousTtName = previousSplit.trafficTypeName;\n          this.ttCache[previousTtName]--;\n          if (!this.ttCache[previousTtName]) delete this.ttCache[previousTtName];\n        }\n\n        if (usesSegments(previousSplit.conditions)) {\n          // Substract from segments count for the previous version of this Split.\n          this.splitsWithSegmentsCount--;\n        }\n      }\n\n      var parsedSplit = JSON.parse(split);\n\n      if (parsedSplit) {\n        // Store the Split.\n        this.splitCache.set(splitName, split); // Update TT cache\n\n        var ttName = parsedSplit.trafficTypeName;\n\n        if (ttName) {\n          // safeguard\n          if (!this.ttCache[ttName]) this.ttCache[ttName] = 0;\n          this.ttCache[ttName]++;\n        } // Add to segments count for the new version of the Split\n\n\n        if (usesSegments(parsedSplit.conditions)) this.splitsWithSegmentsCount++;\n        return true;\n      } else {\n        return false;\n      }\n    }\n  }, {\n    key: \"addSplits\",\n    value: function addSplits(entries) {\n      var results = [];\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = _getIterator(entries), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var _step$value = _slicedToArray(_step.value, 2),\n              key = _step$value[0],\n              value = _step$value[1];\n\n          results.push(this.addSplit(key, value));\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return results;\n    }\n  }, {\n    key: \"removeSplit\",\n    value: function removeSplit(splitName) {\n      var split = this.getSplit(splitName);\n\n      if (split) {\n        // Delete the Split\n        this.splitCache[\"delete\"](splitName);\n        var parsedSplit = JSON.parse(split);\n        var ttName = parsedSplit.trafficTypeName;\n\n        if (ttName) {\n          // safeguard\n          this.ttCache[ttName]--; // Update tt cache\n\n          if (!this.ttCache[ttName]) delete this.ttCache[ttName];\n        } // Update the segments count.\n\n\n        if (usesSegments(parsedSplit.conditions)) this.splitsWithSegmentsCount--;\n        return 1;\n      } else {\n        return 0;\n      }\n    }\n  }, {\n    key: \"removeSplits\",\n    value: function removeSplits(splitNames) {\n      var _this = this;\n\n      _forEachInstanceProperty(splitNames).call(splitNames, function (n) {\n        return _this.removeSplit(n);\n      });\n\n      return splitNames.length;\n    }\n  }, {\n    key: \"getSplit\",\n    value: function getSplit(splitName) {\n      return this.splitCache.get(splitName);\n    }\n  }, {\n    key: \"setChangeNumber\",\n    value: function setChangeNumber(changeNumber) {\n      this.changeNumber = changeNumber;\n      return true;\n    }\n  }, {\n    key: \"getChangeNumber\",\n    value: function getChangeNumber() {\n      return this.changeNumber;\n    }\n  }, {\n    key: \"getAll\",\n    value: function getAll() {\n      var _context;\n\n      return _toConsumableArray(_valuesInstanceProperty(_context = this.splitCache).call(_context));\n    }\n  }, {\n    key: \"getKeys\",\n    value: function getKeys() {\n      var _context2;\n\n      return _toConsumableArray(_keysInstanceProperty(_context2 = this.splitCache).call(_context2));\n    }\n  }, {\n    key: \"trafficTypeExists\",\n    value: function trafficTypeExists(trafficType) {\n      return isFinite(this.ttCache[trafficType]) && this.ttCache[trafficType] > 0;\n    }\n  }, {\n    key: \"usesSegments\",\n    value: function usesSegments() {\n      return this.getChangeNumber() === -1 || this.splitsWithSegmentsCount > 0;\n    }\n  }, {\n    key: \"flush\",\n    value: function flush() {\n      this.splitCache = new _Map();\n      this.ttCache = {};\n      this.changeNumber = -1;\n      this.splitsWithSegmentsCount = 0;\n    }\n    /**\n     * Fetches multiple splits definitions.\n     */\n\n  }, {\n    key: \"fetchMany\",\n    value: function fetchMany(splitNames) {\n      var _this2 = this;\n\n      var splits = new _Map();\n\n      _forEachInstanceProperty(splitNames).call(splitNames, function (splitName) {\n        splits.set(splitName, _this2.splitCache.get(splitName) || null);\n      });\n\n      return splits;\n    }\n    /**\n     * Check if the splits information is already stored in cache. In memory there is no cache to check.\n     */\n\n  }, {\n    key: \"checkCache\",\n    value: function checkCache() {\n      return false;\n    }\n  }]);\n\n  return SplitCacheInMemory;\n}();\n\nexport default SplitCacheInMemory;"]},"metadata":{},"sourceType":"module"}