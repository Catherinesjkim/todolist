{"ast":null,"code":"import _setTimeout from \"@babel/runtime-corejs3/core-js-stable/set-timeout\";\nimport _JSON$stringify from \"@babel/runtime-corejs3/core-js-stable/json/stringify\";\nimport _Promise from \"@babel/runtime-corejs3/core-js-stable/promise\";\nimport logFactory from '../utils/logger';\nvar log = logFactory('splitio-events');\nimport tracker from '../utils/timeTracker';\nimport repeat from '../utils/fn/repeat';\nimport eventsService from '../services/events';\nimport eventsBulkRequest from '../services/events/bulk';\n\nvar EventsFactory = function EventsFactory(context) {\n  var settings = context.get(context.constants.SETTINGS);\n  var storage = context.get(context.constants.STORAGE);\n\n  var pushEvents = function pushEvents() {\n    if (storage.events.isEmpty()) return _Promise.resolve();\n    log.info(\"Pushing \".concat(storage.events.state().length, \" queued events.\"));\n    var latencyTrackerStop = tracker.start(tracker.TaskNames.EVENTS_PUSH);\n\n    var json = _JSON$stringify(storage.events.toJSON());\n\n    var wrapUpCb = function wrapUpCb() {\n      return latencyTrackerStop();\n    };\n\n    storage.events.clear(); // we always clear the queue.\n\n    return eventsService(eventsBulkRequest(settings, {\n      data: json\n    })).then(wrapUpCb)[\"catch\"](wrapUpCb);\n  };\n\n  var stopEventPublisherTimeout = false;\n  var stopEventsPublisher = false;\n\n  var startEventsPublisher = function startEventsPublisher() {\n    return stopEventsPublisher = repeat(function (schedulePublisher) {\n      return pushEvents().then(function () {\n        return schedulePublisher();\n      });\n    }, settings.scheduler.eventsPushRate);\n  };\n\n  return {\n    start: function start() {\n      // On the browser there may be a wish to wait an specific amount of seconds before the first push.\n      if (settings.startup.eventsFirstPushWindow > 0) {\n        stopEventPublisherTimeout = _setTimeout(startEventsPublisher, settings.startup.eventsFirstPushWindow);\n      } else {\n        startEventsPublisher();\n      }\n    },\n    flush: function flush() {\n      return pushEvents();\n    },\n    stop: function stop() {\n      stopEventPublisherTimeout && clearTimeout(stopEventPublisherTimeout);\n      stopEventsPublisher && stopEventsPublisher();\n    },\n    flushAndResetTimer: function flushAndResetTimer() {\n      // Reset the timer and push the events.\n      log.info('Flushing events and reseting timer.');\n      stopEventsPublisher && stopEventsPublisher.reset();\n      return pushEvents();\n    }\n  };\n};\n\nexport default EventsFactory;","map":{"version":3,"sources":["/Users/talianassi/node_modules/@splitsoftware/splitio/es/events/index.js"],"names":["_setTimeout","_JSON$stringify","_Promise","logFactory","log","tracker","repeat","eventsService","eventsBulkRequest","EventsFactory","context","settings","get","constants","SETTINGS","storage","STORAGE","pushEvents","events","isEmpty","resolve","info","concat","state","length","latencyTrackerStop","start","TaskNames","EVENTS_PUSH","json","toJSON","wrapUpCb","clear","data","then","stopEventPublisherTimeout","stopEventsPublisher","startEventsPublisher","schedulePublisher","scheduler","eventsPushRate","startup","eventsFirstPushWindow","flush","stop","clearTimeout","flushAndResetTimer","reset"],"mappings":"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","sourcesContent":["import _setTimeout from \"@babel/runtime-corejs3/core-js-stable/set-timeout\";\nimport _JSON$stringify from \"@babel/runtime-corejs3/core-js-stable/json/stringify\";\nimport _Promise from \"@babel/runtime-corejs3/core-js-stable/promise\";\nimport logFactory from '../utils/logger';\nvar log = logFactory('splitio-events');\nimport tracker from '../utils/timeTracker';\nimport repeat from '../utils/fn/repeat';\nimport eventsService from '../services/events';\nimport eventsBulkRequest from '../services/events/bulk';\n\nvar EventsFactory = function EventsFactory(context) {\n  var settings = context.get(context.constants.SETTINGS);\n  var storage = context.get(context.constants.STORAGE);\n\n  var pushEvents = function pushEvents() {\n    if (storage.events.isEmpty()) return _Promise.resolve();\n    log.info(\"Pushing \".concat(storage.events.state().length, \" queued events.\"));\n    var latencyTrackerStop = tracker.start(tracker.TaskNames.EVENTS_PUSH);\n\n    var json = _JSON$stringify(storage.events.toJSON());\n\n    var wrapUpCb = function wrapUpCb() {\n      return latencyTrackerStop();\n    };\n\n    storage.events.clear(); // we always clear the queue.\n\n    return eventsService(eventsBulkRequest(settings, {\n      data: json\n    })).then(wrapUpCb)[\"catch\"](wrapUpCb);\n  };\n\n  var stopEventPublisherTimeout = false;\n  var stopEventsPublisher = false;\n\n  var startEventsPublisher = function startEventsPublisher() {\n    return stopEventsPublisher = repeat(function (schedulePublisher) {\n      return pushEvents().then(function () {\n        return schedulePublisher();\n      });\n    }, settings.scheduler.eventsPushRate);\n  };\n\n  return {\n    start: function start() {\n      // On the browser there may be a wish to wait an specific amount of seconds before the first push.\n      if (settings.startup.eventsFirstPushWindow > 0) {\n        stopEventPublisherTimeout = _setTimeout(startEventsPublisher, settings.startup.eventsFirstPushWindow);\n      } else {\n        startEventsPublisher();\n      }\n    },\n    flush: function flush() {\n      return pushEvents();\n    },\n    stop: function stop() {\n      stopEventPublisherTimeout && clearTimeout(stopEventPublisherTimeout);\n      stopEventsPublisher && stopEventsPublisher();\n    },\n    flushAndResetTimer: function flushAndResetTimer() {\n      // Reset the timer and push the events.\n      log.info('Flushing events and reseting timer.');\n      stopEventsPublisher && stopEventsPublisher.reset();\n      return pushEvents();\n    }\n  };\n};\n\nexport default EventsFactory;"]},"metadata":{},"sourceType":"module"}