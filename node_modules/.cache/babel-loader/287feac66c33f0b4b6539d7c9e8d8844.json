{"ast":null,"code":"import _Object$create from \"@babel/runtime-corejs3/core-js-stable/object/create\";\nimport _Object$assign from \"@babel/runtime-corejs3/core-js-stable/object/assign\";\nimport _getIterator from \"@babel/runtime-corejs3/core-js/get-iterator\";\nimport _mapInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/map\";\nimport thenable from '../utils/promise/thenable';\nimport { find } from '../utils/lang';\nimport { validateSplit, validateSplitExistance, validateIfDestroyed, validateIfReady } from '../utils/inputValidation';\n\nvar collectTreatments = function collectTreatments(splitObject) {\n  var _context;\n\n  var conditions = splitObject.conditions; // Rollout conditions are supposed to have the entire partitions list, so we find the first one.\n\n  var allTreatmentsCondition = find(conditions, function (cond) {\n    return cond.conditionType === 'ROLLOUT';\n  }); // Localstorage mode could fall into a no rollout conditions state. Take the first condition in that case.\n\n  if (!allTreatmentsCondition) allTreatmentsCondition = conditions[0]; // Then extract the treatments from the partitions\n\n  return allTreatmentsCondition ? _mapInstanceProperty(_context = allTreatmentsCondition.partitions).call(_context, function (v) {\n    return v.treatment;\n  }) : [];\n};\n\nvar ObjectToView = function ObjectToView(json) {\n  var splitObject;\n\n  try {\n    splitObject = JSON.parse(json);\n  } catch (e) {\n    return null;\n  }\n\n  if (splitObject == null) return null;\n  return {\n    name: splitObject.name,\n    trafficType: splitObject.trafficTypeName || null,\n    killed: splitObject.killed,\n    changeNumber: splitObject.changeNumber || 0,\n    treatments: collectTreatments(splitObject),\n    configs: splitObject.configurations || {}\n  };\n};\n\nvar ObjectsToViews = function ObjectsToViews(jsons) {\n  var views = [];\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = _getIterator(jsons), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var split = _step.value;\n      var view = ObjectToView(split);\n      if (view != null) views.push(view);\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n        _iterator[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return views;\n};\n\nvar SplitManagerFactory = function SplitManagerFactory(_splits, context) {\n  var SPLIT_FN_LABEL = 'split';\n  var statusManager = context.get(context.constants.STATUS_MANAGER);\n  return _Object$assign( // Proto-linkage of the readiness Event Emitter\n  _Object$create(statusManager), {\n    /**\n     * Get the Split object corresponding to the given split name if valid\n     */\n    split: function split(maybeSplitName) {\n      var splitName = validateSplit(maybeSplitName, SPLIT_FN_LABEL);\n\n      if (!validateIfDestroyed(context) || !validateIfReady(context, SPLIT_FN_LABEL) || !splitName) {\n        return null;\n      }\n\n      var split = _splits.getSplit(splitName);\n\n      if (thenable(split)) {\n        return split.then(function (result) {\n          validateSplitExistance(context, splitName, result, SPLIT_FN_LABEL);\n          return ObjectToView(result);\n        });\n      }\n\n      validateSplitExistance(context, splitName, split, SPLIT_FN_LABEL);\n      return ObjectToView(split);\n    },\n\n    /**\n     * Get the Split objects present on the factory storage\n     */\n    splits: function splits() {\n      if (!validateIfDestroyed(context) || !validateIfReady(context, 'splits')) {\n        return [];\n      }\n\n      var currentSplits = _splits.getAll();\n\n      if (thenable(currentSplits)) return currentSplits.then(ObjectsToViews);\n      return ObjectsToViews(currentSplits);\n    },\n\n    /**\n     * Get the Split names present on the factory storage\n     */\n    names: function names() {\n      if (!validateIfDestroyed(context) || !validateIfReady(context, 'names')) {\n        return [];\n      }\n\n      return _splits.getKeys();\n    }\n  });\n};\n\nexport default SplitManagerFactory;","map":{"version":3,"sources":["/Users/talianassi/node_modules/@splitsoftware/splitio/es/manager/index.js"],"names":["_Object$create","_Object$assign","_getIterator","_mapInstanceProperty","thenable","find","validateSplit","validateSplitExistance","validateIfDestroyed","validateIfReady","collectTreatments","splitObject","_context","conditions","allTreatmentsCondition","cond","conditionType","partitions","call","v","treatment","ObjectToView","json","JSON","parse","e","name","trafficType","trafficTypeName","killed","changeNumber","treatments","configs","configurations","ObjectsToViews","jsons","views","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_iterator","_step","next","done","split","value","view","push","err","SplitManagerFactory","_splits","context","SPLIT_FN_LABEL","statusManager","get","constants","STATUS_MANAGER","maybeSplitName","splitName","getSplit","then","result","splits","currentSplits","getAll","names","getKeys"],"mappings":"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","sourcesContent":["import _Object$create from \"@babel/runtime-corejs3/core-js-stable/object/create\";\nimport _Object$assign from \"@babel/runtime-corejs3/core-js-stable/object/assign\";\nimport _getIterator from \"@babel/runtime-corejs3/core-js/get-iterator\";\nimport _mapInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/map\";\nimport thenable from '../utils/promise/thenable';\nimport { find } from '../utils/lang';\nimport { validateSplit, validateSplitExistance, validateIfDestroyed, validateIfReady } from '../utils/inputValidation';\n\nvar collectTreatments = function collectTreatments(splitObject) {\n  var _context;\n\n  var conditions = splitObject.conditions; // Rollout conditions are supposed to have the entire partitions list, so we find the first one.\n\n  var allTreatmentsCondition = find(conditions, function (cond) {\n    return cond.conditionType === 'ROLLOUT';\n  }); // Localstorage mode could fall into a no rollout conditions state. Take the first condition in that case.\n\n  if (!allTreatmentsCondition) allTreatmentsCondition = conditions[0]; // Then extract the treatments from the partitions\n\n  return allTreatmentsCondition ? _mapInstanceProperty(_context = allTreatmentsCondition.partitions).call(_context, function (v) {\n    return v.treatment;\n  }) : [];\n};\n\nvar ObjectToView = function ObjectToView(json) {\n  var splitObject;\n\n  try {\n    splitObject = JSON.parse(json);\n  } catch (e) {\n    return null;\n  }\n\n  if (splitObject == null) return null;\n  return {\n    name: splitObject.name,\n    trafficType: splitObject.trafficTypeName || null,\n    killed: splitObject.killed,\n    changeNumber: splitObject.changeNumber || 0,\n    treatments: collectTreatments(splitObject),\n    configs: splitObject.configurations || {}\n  };\n};\n\nvar ObjectsToViews = function ObjectsToViews(jsons) {\n  var views = [];\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = _getIterator(jsons), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var split = _step.value;\n      var view = ObjectToView(split);\n      if (view != null) views.push(view);\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n        _iterator[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return views;\n};\n\nvar SplitManagerFactory = function SplitManagerFactory(_splits, context) {\n  var SPLIT_FN_LABEL = 'split';\n  var statusManager = context.get(context.constants.STATUS_MANAGER);\n  return _Object$assign( // Proto-linkage of the readiness Event Emitter\n  _Object$create(statusManager), {\n    /**\n     * Get the Split object corresponding to the given split name if valid\n     */\n    split: function split(maybeSplitName) {\n      var splitName = validateSplit(maybeSplitName, SPLIT_FN_LABEL);\n\n      if (!validateIfDestroyed(context) || !validateIfReady(context, SPLIT_FN_LABEL) || !splitName) {\n        return null;\n      }\n\n      var split = _splits.getSplit(splitName);\n\n      if (thenable(split)) {\n        return split.then(function (result) {\n          validateSplitExistance(context, splitName, result, SPLIT_FN_LABEL);\n          return ObjectToView(result);\n        });\n      }\n\n      validateSplitExistance(context, splitName, split, SPLIT_FN_LABEL);\n      return ObjectToView(split);\n    },\n\n    /**\n     * Get the Split objects present on the factory storage\n     */\n    splits: function splits() {\n      if (!validateIfDestroyed(context) || !validateIfReady(context, 'splits')) {\n        return [];\n      }\n\n      var currentSplits = _splits.getAll();\n\n      if (thenable(currentSplits)) return currentSplits.then(ObjectsToViews);\n      return ObjectsToViews(currentSplits);\n    },\n\n    /**\n     * Get the Split names present on the factory storage\n     */\n    names: function names() {\n      if (!validateIfDestroyed(context) || !validateIfReady(context, 'names')) {\n        return [];\n      }\n\n      return _splits.getKeys();\n    }\n  });\n};\n\nexport default SplitManagerFactory;"]},"metadata":{},"sourceType":"module"}