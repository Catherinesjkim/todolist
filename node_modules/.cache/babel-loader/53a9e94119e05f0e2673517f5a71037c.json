{"ast":null,"code":"import React from 'react';\nimport SplitContext from './SplitContext';\nimport { ERROR_SC_NO_FACTORY } from './constants';\nimport { getClientWithStatus } from './utils';\n/**\n * SplitClient will initialize a new Split Client and listen for its events in order to update the Split Context.\n * Children components will have access to this new client when accessing the Split Context.\n *\n * @see {@link https://help.split.io/hc/en-us/articles/360020448791-JavaScript-SDK#advanced-instantiate-multiple-sdk-clients}\n */\n\nclass SplitClient extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.sdkUpdate = () => {\n      this.setState({\n        lastUpdate: Date.now()\n      });\n    };\n\n    const {\n      splitKey,\n      trafficType,\n      updateOnSdkUpdate,\n      updateOnSdkTimedout,\n      updateOnSdkReady,\n      splitContext: {\n        factory\n      }\n    } = props; // Log error if factory is not available\n\n    if (!factory) {\n      console.error(ERROR_SC_NO_FACTORY);\n    } // Init new client\n\n\n    const client = factory ? getClientWithStatus(factory, splitKey, trafficType) : null;\n\n    if (client) {\n      this.subscribeToEvents(client, updateOnSdkUpdate, updateOnSdkTimedout, updateOnSdkReady);\n    }\n\n    this.state = Object.assign(Object.assign({}, props.splitContext), {\n      client,\n      isReady: client ? client.isReady : false,\n      isTimedout: client ? client.isTimedout : false\n    });\n  } // Listen SDK events. This method will be updated when SDK provides self synchronous status\n\n\n  subscribeToEvents(client, updateOnSdkUpdate, updateOnSdkTimedout, updateOnSdkReady) {\n    if (!client.isReady) {\n      // client is not ready\n\n      /**\n       * client still might be ready if it was created before using `getClientWithStatus` function\n       * (for example if the client was instantiated outside SplitClient),\n       * thus we have to use the ready() promise instead of an event listener.\n       */\n      client.ready().then(() => {\n        // Update isReady if the client was not changed and updateOnSdkReady is true\n        if (this.state.client === client && updateOnSdkReady) {\n          this.setState({\n            isReady: true,\n            isTimedout: false,\n            lastUpdate: Date.now()\n          });\n        }\n      }, () => {\n        // Update isTimedout if the client was not changed and updateOnSdkTimedout is true\n        if (this.state.client === client) {\n          if (updateOnSdkTimedout) {\n            this.setState({\n              isTimedout: true,\n              lastUpdate: Date.now()\n            });\n          } // register a listener for SDK_READY event, that might trigger after a timeout\n\n\n          client.once(client.Event.SDK_READY, () => {\n            // Update isReady if the client was not changed and updateOnSdkReady is true\n            if (this.state.client === client && updateOnSdkReady) {\n              this.setState({\n                isReady: true,\n                isTimedout: false,\n                lastUpdate: Date.now()\n              });\n            }\n          });\n        }\n      });\n    } // register a listener for SDK_UPDATE event\n\n\n    if (updateOnSdkUpdate) {\n      client.on(client.Event.SDK_UPDATE, this.sdkUpdate);\n    }\n  }\n\n  shouldComponentUpdate({\n    splitContext: {\n      factory\n    },\n    splitKey,\n    trafficType,\n    updateOnSdkReady,\n    updateOnSdkTimedout,\n    updateOnSdkUpdate\n  }, nextState) {\n    const client = factory ? getClientWithStatus(factory, splitKey, trafficType) : null;\n\n    if (client !== nextState.client && client) {\n      this.subscribeToEvents(client, updateOnSdkUpdate, updateOnSdkTimedout, updateOnSdkReady); // Deregister listener for previous client\n\n      if (nextState.client) {\n        nextState.client.removeListener(client.Event.SDK_UPDATE, this.sdkUpdate);\n      }\n\n      this.setState({\n        client,\n        isReady: client ? client.isReady : false,\n        isTimedout: client ? client.isTimedout : false\n      });\n      return false;\n    } // Update when the client or its status change\n    // (no need to compara isReady or isTimedout, lastUpdate is enough).\n    // Don't update when updateOnSdk** props change.\n\n\n    return this.state.client !== nextState.client || this.state.lastUpdate !== nextState.lastUpdate;\n  }\n\n  render() {\n    const {\n      children\n    } = this.props;\n    const {\n      client,\n      isReady,\n      isTimedout,\n      lastUpdate\n    } = this.state;\n    return React.createElement(SplitContext.Provider, {\n      value: this.state\n    }, typeof children === 'function' ? children({\n      client,\n      isReady,\n      isTimedout,\n      lastUpdate\n    }) : children);\n  }\n\n}\n\nSplitClient.contextType = SplitContext;\nSplitClient.defaultProps = {\n  updateOnSdkUpdate: false,\n  updateOnSdkTimedout: false,\n  updateOnSdkReady: true,\n  children: null\n}; // Wrapper to access Split context on SplitClient constructor\n\nexport default (props => React.createElement(SplitContext.Consumer, null, splitContext => React.createElement(SplitClient, Object.assign({}, props, {\n  splitContext: splitContext\n}))));","map":{"version":3,"sources":["/Users/talianassi/Desktop/todolist/node_modules/@splitsoftware/splitio-react/es/SplitClient.js"],"names":["React","SplitContext","ERROR_SC_NO_FACTORY","getClientWithStatus","SplitClient","Component","constructor","props","sdkUpdate","setState","lastUpdate","Date","now","splitKey","trafficType","updateOnSdkUpdate","updateOnSdkTimedout","updateOnSdkReady","splitContext","factory","console","error","client","subscribeToEvents","state","Object","assign","isReady","isTimedout","ready","then","once","Event","SDK_READY","on","SDK_UPDATE","shouldComponentUpdate","nextState","removeListener","render","children","createElement","Provider","value","contextType","defaultProps","Consumer"],"mappings":"AAAA,OAAOA,KAAP,MAAkB,OAAlB;AACA,OAAOC,YAAP,MAAyB,gBAAzB;AACA,SAASC,mBAAT,QAAoC,aAApC;AACA,SAASC,mBAAT,QAAoC,SAApC;AACA;;;;;;;AAMA,MAAMC,WAAN,SAA0BJ,KAAK,CAACK,SAAhC,CAA0C;AACtCC,EAAAA,WAAW,CAACC,KAAD,EAAQ;AACf,UAAMA,KAAN;;AACA,SAAKC,SAAL,GAAiB,MAAM;AACnB,WAAKC,QAAL,CAAc;AAAEC,QAAAA,UAAU,EAAEC,IAAI,CAACC,GAAL;AAAd,OAAd;AACH,KAFD;;AAGA,UAAM;AAAEC,MAAAA,QAAF;AAAYC,MAAAA,WAAZ;AAAyBC,MAAAA,iBAAzB;AAA4CC,MAAAA,mBAA5C;AAAiEC,MAAAA,gBAAjE;AAAmFC,MAAAA,YAAY,EAAE;AAAEC,QAAAA;AAAF;AAAjG,QAAiHZ,KAAvH,CALe,CAMf;;AACA,QAAI,CAACY,OAAL,EAAc;AACVC,MAAAA,OAAO,CAACC,KAAR,CAAcnB,mBAAd;AACH,KATc,CAUf;;;AACA,UAAMoB,MAAM,GAAGH,OAAO,GAAGhB,mBAAmB,CAACgB,OAAD,EAAUN,QAAV,EAAoBC,WAApB,CAAtB,GAAyD,IAA/E;;AACA,QAAIQ,MAAJ,EAAY;AACR,WAAKC,iBAAL,CAAuBD,MAAvB,EAA+BP,iBAA/B,EAAkDC,mBAAlD,EAAuEC,gBAAvE;AACH;;AACD,SAAKO,KAAL,GAAaC,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBnB,KAAK,CAACW,YAAxB,CAAd,EAAqD;AAAEI,MAAAA,MAAF;AAAUK,MAAAA,OAAO,EAAEL,MAAM,GAAGA,MAAM,CAACK,OAAV,GAAoB,KAA7C;AAAoDC,MAAAA,UAAU,EAAEN,MAAM,GAAGA,MAAM,CAACM,UAAV,GAAuB;AAA7F,KAArD,CAAb;AACH,GAjBqC,CAkBtC;;;AACAL,EAAAA,iBAAiB,CAACD,MAAD,EAASP,iBAAT,EAA4BC,mBAA5B,EAAiDC,gBAAjD,EAAmE;AAChF,QAAI,CAACK,MAAM,CAACK,OAAZ,EAAqB;AAAE;;AACnB;;;;;AAKAL,MAAAA,MAAM,CAACO,KAAP,GAAeC,IAAf,CAAoB,MAAM;AACtB;AACA,YAAI,KAAKN,KAAL,CAAWF,MAAX,KAAsBA,MAAtB,IAAgCL,gBAApC,EAAsD;AAClD,eAAKR,QAAL,CAAc;AAAEkB,YAAAA,OAAO,EAAE,IAAX;AAAiBC,YAAAA,UAAU,EAAE,KAA7B;AAAoClB,YAAAA,UAAU,EAAEC,IAAI,CAACC,GAAL;AAAhD,WAAd;AACH;AACJ,OALD,EAKG,MAAM;AACL;AACA,YAAI,KAAKY,KAAL,CAAWF,MAAX,KAAsBA,MAA1B,EAAkC;AAC9B,cAAIN,mBAAJ,EAAyB;AACrB,iBAAKP,QAAL,CAAc;AAAEmB,cAAAA,UAAU,EAAE,IAAd;AAAoBlB,cAAAA,UAAU,EAAEC,IAAI,CAACC,GAAL;AAAhC,aAAd;AACH,WAH6B,CAI9B;;;AACAU,UAAAA,MAAM,CAACS,IAAP,CAAYT,MAAM,CAACU,KAAP,CAAaC,SAAzB,EAAoC,MAAM;AACtC;AACA,gBAAI,KAAKT,KAAL,CAAWF,MAAX,KAAsBA,MAAtB,IAAgCL,gBAApC,EAAsD;AAClD,mBAAKR,QAAL,CAAc;AAAEkB,gBAAAA,OAAO,EAAE,IAAX;AAAiBC,gBAAAA,UAAU,EAAE,KAA7B;AAAoClB,gBAAAA,UAAU,EAAEC,IAAI,CAACC,GAAL;AAAhD,eAAd;AACH;AACJ,WALD;AAMH;AACJ,OAnBD;AAoBH,KA3B+E,CA4BhF;;;AACA,QAAIG,iBAAJ,EAAuB;AACnBO,MAAAA,MAAM,CAACY,EAAP,CAAUZ,MAAM,CAACU,KAAP,CAAaG,UAAvB,EAAmC,KAAK3B,SAAxC;AACH;AACJ;;AACD4B,EAAAA,qBAAqB,CAAC;AAAElB,IAAAA,YAAY,EAAE;AAAEC,MAAAA;AAAF,KAAhB;AAA6BN,IAAAA,QAA7B;AAAuCC,IAAAA,WAAvC;AAAoDG,IAAAA,gBAApD;AAAsED,IAAAA,mBAAtE;AAA2FD,IAAAA;AAA3F,GAAD,EAAiHsB,SAAjH,EAA4H;AAC7I,UAAMf,MAAM,GAAGH,OAAO,GAAGhB,mBAAmB,CAACgB,OAAD,EAAUN,QAAV,EAAoBC,WAApB,CAAtB,GAAyD,IAA/E;;AACA,QAAIQ,MAAM,KAAKe,SAAS,CAACf,MAArB,IAA+BA,MAAnC,EAA2C;AACvC,WAAKC,iBAAL,CAAuBD,MAAvB,EAA+BP,iBAA/B,EAAkDC,mBAAlD,EAAuEC,gBAAvE,EADuC,CAEvC;;AACA,UAAIoB,SAAS,CAACf,MAAd,EAAsB;AAClBe,QAAAA,SAAS,CAACf,MAAV,CAAiBgB,cAAjB,CAAgChB,MAAM,CAACU,KAAP,CAAaG,UAA7C,EAAyD,KAAK3B,SAA9D;AACH;;AACD,WAAKC,QAAL,CAAc;AACVa,QAAAA,MADU;AAEVK,QAAAA,OAAO,EAAEL,MAAM,GAAGA,MAAM,CAACK,OAAV,GAAoB,KAFzB;AAGVC,QAAAA,UAAU,EAAEN,MAAM,GAAGA,MAAM,CAACM,UAAV,GAAuB;AAH/B,OAAd;AAKA,aAAO,KAAP;AACH,KAd4I,CAe7I;AACA;AACA;;;AACA,WAAO,KAAKJ,KAAL,CAAWF,MAAX,KAAsBe,SAAS,CAACf,MAAhC,IACH,KAAKE,KAAL,CAAWd,UAAX,KAA0B2B,SAAS,CAAC3B,UADxC;AAEH;;AACD6B,EAAAA,MAAM,GAAG;AACL,UAAM;AAAEC,MAAAA;AAAF,QAAe,KAAKjC,KAA1B;AACA,UAAM;AAAEe,MAAAA,MAAF;AAAUK,MAAAA,OAAV;AAAmBC,MAAAA,UAAnB;AAA+BlB,MAAAA;AAA/B,QAA8C,KAAKc,KAAzD;AACA,WAAQxB,KAAK,CAACyC,aAAN,CAAoBxC,YAAY,CAACyC,QAAjC,EAA2C;AAAEC,MAAAA,KAAK,EAAE,KAAKnB;AAAd,KAA3C,EAAkE,OAAOgB,QAAP,KAAoB,UAApB,GACtEA,QAAQ,CAAC;AAAElB,MAAAA,MAAF;AAAUK,MAAAA,OAAV;AAAmBC,MAAAA,UAAnB;AAA+BlB,MAAAA;AAA/B,KAAD,CAD8D,GAEtE8B,QAFI,CAAR;AAGH;;AA/EqC;;AAiF1CpC,WAAW,CAACwC,WAAZ,GAA0B3C,YAA1B;AACAG,WAAW,CAACyC,YAAZ,GAA2B;AACvB9B,EAAAA,iBAAiB,EAAE,KADI;AAEvBC,EAAAA,mBAAmB,EAAE,KAFE;AAGvBC,EAAAA,gBAAgB,EAAE,IAHK;AAIvBuB,EAAAA,QAAQ,EAAE;AAJa,CAA3B,C,CAMA;;AACA,gBAAgBjC,KAAD,IAAYP,KAAK,CAACyC,aAAN,CAAoBxC,YAAY,CAAC6C,QAAjC,EAA2C,IAA3C,EAAkD5B,YAAD,IAAkBlB,KAAK,CAACyC,aAAN,CAAoBrC,WAApB,EAAiCqB,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBnB,KAAlB,EAAyB;AAAEW,EAAAA,YAAY,EAAEA;AAAhB,CAAzB,CAAjC,CAAnE,CAA3B","sourcesContent":["import React from 'react';\nimport SplitContext from './SplitContext';\nimport { ERROR_SC_NO_FACTORY } from './constants';\nimport { getClientWithStatus } from './utils';\n/**\n * SplitClient will initialize a new Split Client and listen for its events in order to update the Split Context.\n * Children components will have access to this new client when accessing the Split Context.\n *\n * @see {@link https://help.split.io/hc/en-us/articles/360020448791-JavaScript-SDK#advanced-instantiate-multiple-sdk-clients}\n */\nclass SplitClient extends React.Component {\n    constructor(props) {\n        super(props);\n        this.sdkUpdate = () => {\n            this.setState({ lastUpdate: Date.now() });\n        };\n        const { splitKey, trafficType, updateOnSdkUpdate, updateOnSdkTimedout, updateOnSdkReady, splitContext: { factory } } = props;\n        // Log error if factory is not available\n        if (!factory) {\n            console.error(ERROR_SC_NO_FACTORY);\n        }\n        // Init new client\n        const client = factory ? getClientWithStatus(factory, splitKey, trafficType) : null;\n        if (client) {\n            this.subscribeToEvents(client, updateOnSdkUpdate, updateOnSdkTimedout, updateOnSdkReady);\n        }\n        this.state = Object.assign(Object.assign({}, props.splitContext), { client, isReady: client ? client.isReady : false, isTimedout: client ? client.isTimedout : false });\n    }\n    // Listen SDK events. This method will be updated when SDK provides self synchronous status\n    subscribeToEvents(client, updateOnSdkUpdate, updateOnSdkTimedout, updateOnSdkReady) {\n        if (!client.isReady) { // client is not ready\n            /**\n             * client still might be ready if it was created before using `getClientWithStatus` function\n             * (for example if the client was instantiated outside SplitClient),\n             * thus we have to use the ready() promise instead of an event listener.\n             */\n            client.ready().then(() => {\n                // Update isReady if the client was not changed and updateOnSdkReady is true\n                if (this.state.client === client && updateOnSdkReady) {\n                    this.setState({ isReady: true, isTimedout: false, lastUpdate: Date.now() });\n                }\n            }, () => {\n                // Update isTimedout if the client was not changed and updateOnSdkTimedout is true\n                if (this.state.client === client) {\n                    if (updateOnSdkTimedout) {\n                        this.setState({ isTimedout: true, lastUpdate: Date.now() });\n                    }\n                    // register a listener for SDK_READY event, that might trigger after a timeout\n                    client.once(client.Event.SDK_READY, () => {\n                        // Update isReady if the client was not changed and updateOnSdkReady is true\n                        if (this.state.client === client && updateOnSdkReady) {\n                            this.setState({ isReady: true, isTimedout: false, lastUpdate: Date.now() });\n                        }\n                    });\n                }\n            });\n        }\n        // register a listener for SDK_UPDATE event\n        if (updateOnSdkUpdate) {\n            client.on(client.Event.SDK_UPDATE, this.sdkUpdate);\n        }\n    }\n    shouldComponentUpdate({ splitContext: { factory }, splitKey, trafficType, updateOnSdkReady, updateOnSdkTimedout, updateOnSdkUpdate }, nextState) {\n        const client = factory ? getClientWithStatus(factory, splitKey, trafficType) : null;\n        if (client !== nextState.client && client) {\n            this.subscribeToEvents(client, updateOnSdkUpdate, updateOnSdkTimedout, updateOnSdkReady);\n            // Deregister listener for previous client\n            if (nextState.client) {\n                nextState.client.removeListener(client.Event.SDK_UPDATE, this.sdkUpdate);\n            }\n            this.setState({\n                client,\n                isReady: client ? client.isReady : false,\n                isTimedout: client ? client.isTimedout : false,\n            });\n            return false;\n        }\n        // Update when the client or its status change\n        // (no need to compara isReady or isTimedout, lastUpdate is enough).\n        // Don't update when updateOnSdk** props change.\n        return this.state.client !== nextState.client ||\n            this.state.lastUpdate !== nextState.lastUpdate;\n    }\n    render() {\n        const { children } = this.props;\n        const { client, isReady, isTimedout, lastUpdate } = this.state;\n        return (React.createElement(SplitContext.Provider, { value: this.state }, typeof children === 'function' ?\n            children({ client, isReady, isTimedout, lastUpdate }) :\n            children));\n    }\n}\nSplitClient.contextType = SplitContext;\nSplitClient.defaultProps = {\n    updateOnSdkUpdate: false,\n    updateOnSdkTimedout: false,\n    updateOnSdkReady: true,\n    children: null,\n};\n// Wrapper to access Split context on SplitClient constructor\nexport default (props) => (React.createElement(SplitContext.Consumer, null, (splitContext) => React.createElement(SplitClient, Object.assign({}, props, { splitContext: splitContext }))));\n"]},"metadata":{},"sourceType":"module"}