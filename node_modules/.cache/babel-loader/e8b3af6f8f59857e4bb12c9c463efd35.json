{"ast":null,"code":"import _JSON$stringify from \"@babel/runtime-corejs3/core-js-stable/json/stringify\";\nimport _bindInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/bind\";\nimport _classCallCheck from \"@babel/runtime-corejs3/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime-corejs3/helpers/esm/createClass\";\nimport eventsBulkRequest from '../services/events/bulk';\nimport eventsService from '../services/events';\nimport impressionsBulkRequest from '../services/impressions/bulk';\nimport impressionsService from '../services/impressions';\nimport { fromImpressionsCollector } from '../services/impressions/dto';\nimport logFactory from '../utils/logger';\nvar log = logFactory('splitio-client:cleanup'); // 'unload' event is used instead of 'beforeunload', since 'unload' is not a cancelable event, so no other listeners can stop the event from occurring.\n\nvar UNLOAD_DOM_EVENT = 'unload';\n/**\n * We'll listen for 'unload' event over the window object, since it's the standard way to listen page reload and close.\n *\n */\n\nvar BrowserSignalListener = /*#__PURE__*/function () {\n  function BrowserSignalListener(context) {\n    var _context;\n\n    _classCallCheck(this, BrowserSignalListener);\n\n    this.storage = context.get(context.constants.STORAGE);\n    this.settings = context.get(context.constants.SETTINGS);\n    this.flushData = _bindInstanceProperty(_context = this.flushData).call(_context, this);\n  }\n  /**\n   * start method. \n   * Called when SplitFactory is initialized. \n   * We add a handler on unload events. The handler flushes remaining impressions and events to the backend.\n   */\n\n\n  _createClass(BrowserSignalListener, [{\n    key: \"start\",\n    value: function start() {\n      if (window && window.addEventListener) {\n        log.debug('Registering flush handler when unload page event is triggered.');\n        window.addEventListener(UNLOAD_DOM_EVENT, this.flushData);\n      }\n    }\n    /**\n     * stop method. \n     * Called when client is destroyed. \n     * We need to remove the handler for unload events, since it can break if called when Split context was destroyed.\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (window && window.removeEventListener) {\n        log.debug('Deregistering flush handler when unload page event is triggered.');\n        window.removeEventListener(UNLOAD_DOM_EVENT, this.flushData);\n      }\n    }\n    /**\n     * _flushData method. \n     * Called when unload event is triggered. It flushed remaining impressions and events to the backend, \n     * using beacon API if possible, or falling back to XHR.\n     */\n\n  }, {\n    key: \"flushData\",\n    value: function flushData() {\n      this._flushImpressions();\n\n      this._flushEvents();\n    }\n  }, {\n    key: \"_flushImpressions\",\n    value: function _flushImpressions() {\n      var impressions = this.storage.impressions; // if there are impressions in storage, send them to backend\n\n      if (!impressions.isEmpty()) {\n        var url = this.settings.url('/testImpressions/beacon');\n        var impressionsPayload = fromImpressionsCollector(impressions, this.settings);\n\n        if (!this._sendBeacon(url, impressionsPayload)) {\n          impressionsService(impressionsBulkRequest(this.settings, {\n            data: _JSON$stringify(impressionsPayload)\n          }));\n        }\n\n        impressions.clear();\n      }\n    }\n  }, {\n    key: \"_flushEvents\",\n    value: function _flushEvents() {\n      var events = this.storage.events; // if there are events in storage, send them to backend\n\n      if (!events.isEmpty()) {\n        var url = this.settings.url('/events/beacon');\n        var eventsPayload = events.toJSON();\n\n        if (!this._sendBeacon(url, eventsPayload)) {\n          eventsService(eventsBulkRequest(this.settings, {\n            data: _JSON$stringify(eventsPayload)\n          }));\n        }\n\n        events.clear();\n      }\n    }\n    /**\n     * _sendBeacon method.\n     * Util method that check if beacon API is available, build the payload and send it.\n     */\n\n  }, {\n    key: \"_sendBeacon\",\n    value: function _sendBeacon(url, data) {\n      if (navigator && navigator.sendBeacon) {\n        var payload = _JSON$stringify({\n          entries: data,\n          token: this.settings.core.authorizationKey,\n          sdk: this.settings.version\n        });\n\n        return navigator.sendBeacon(url, payload);\n      }\n\n      return false;\n    }\n  }]);\n\n  return BrowserSignalListener;\n}();\n\nexport { BrowserSignalListener as default };","map":{"version":3,"sources":["/Users/talianassi/Desktop/todolist/node_modules/@splitsoftware/splitio/es/listeners/browser.js"],"names":["_JSON$stringify","_bindInstanceProperty","_classCallCheck","_createClass","eventsBulkRequest","eventsService","impressionsBulkRequest","impressionsService","fromImpressionsCollector","logFactory","log","UNLOAD_DOM_EVENT","BrowserSignalListener","context","_context","storage","get","constants","STORAGE","settings","SETTINGS","flushData","call","key","value","start","window","addEventListener","debug","stop","removeEventListener","_flushImpressions","_flushEvents","impressions","isEmpty","url","impressionsPayload","_sendBeacon","data","clear","events","eventsPayload","toJSON","navigator","sendBeacon","payload","entries","token","core","authorizationKey","sdk","version","default"],"mappings":"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","sourcesContent":["import _JSON$stringify from \"@babel/runtime-corejs3/core-js-stable/json/stringify\";\nimport _bindInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/bind\";\nimport _classCallCheck from \"@babel/runtime-corejs3/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime-corejs3/helpers/esm/createClass\";\nimport eventsBulkRequest from '../services/events/bulk';\nimport eventsService from '../services/events';\nimport impressionsBulkRequest from '../services/impressions/bulk';\nimport impressionsService from '../services/impressions';\nimport { fromImpressionsCollector } from '../services/impressions/dto';\nimport logFactory from '../utils/logger';\nvar log = logFactory('splitio-client:cleanup'); // 'unload' event is used instead of 'beforeunload', since 'unload' is not a cancelable event, so no other listeners can stop the event from occurring.\n\nvar UNLOAD_DOM_EVENT = 'unload';\n/**\n * We'll listen for 'unload' event over the window object, since it's the standard way to listen page reload and close.\n *\n */\n\nvar BrowserSignalListener =\n/*#__PURE__*/\nfunction () {\n  function BrowserSignalListener(context) {\n    var _context;\n\n    _classCallCheck(this, BrowserSignalListener);\n\n    this.storage = context.get(context.constants.STORAGE);\n    this.settings = context.get(context.constants.SETTINGS);\n    this.flushData = _bindInstanceProperty(_context = this.flushData).call(_context, this);\n  }\n  /**\n   * start method. \n   * Called when SplitFactory is initialized. \n   * We add a handler on unload events. The handler flushes remaining impressions and events to the backend.\n   */\n\n\n  _createClass(BrowserSignalListener, [{\n    key: \"start\",\n    value: function start() {\n      if (window && window.addEventListener) {\n        log.debug('Registering flush handler when unload page event is triggered.');\n        window.addEventListener(UNLOAD_DOM_EVENT, this.flushData);\n      }\n    }\n    /**\n     * stop method. \n     * Called when client is destroyed. \n     * We need to remove the handler for unload events, since it can break if called when Split context was destroyed.\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (window && window.removeEventListener) {\n        log.debug('Deregistering flush handler when unload page event is triggered.');\n        window.removeEventListener(UNLOAD_DOM_EVENT, this.flushData);\n      }\n    }\n    /**\n     * _flushData method. \n     * Called when unload event is triggered. It flushed remaining impressions and events to the backend, \n     * using beacon API if possible, or falling back to XHR.\n     */\n\n  }, {\n    key: \"flushData\",\n    value: function flushData() {\n      this._flushImpressions();\n\n      this._flushEvents();\n    }\n  }, {\n    key: \"_flushImpressions\",\n    value: function _flushImpressions() {\n      var impressions = this.storage.impressions; // if there are impressions in storage, send them to backend\n\n      if (!impressions.isEmpty()) {\n        var url = this.settings.url('/testImpressions/beacon');\n        var impressionsPayload = fromImpressionsCollector(impressions, this.settings);\n\n        if (!this._sendBeacon(url, impressionsPayload)) {\n          impressionsService(impressionsBulkRequest(this.settings, {\n            data: _JSON$stringify(impressionsPayload)\n          }));\n        }\n\n        impressions.clear();\n      }\n    }\n  }, {\n    key: \"_flushEvents\",\n    value: function _flushEvents() {\n      var events = this.storage.events; // if there are events in storage, send them to backend\n\n      if (!events.isEmpty()) {\n        var url = this.settings.url('/events/beacon');\n        var eventsPayload = events.toJSON();\n\n        if (!this._sendBeacon(url, eventsPayload)) {\n          eventsService(eventsBulkRequest(this.settings, {\n            data: _JSON$stringify(eventsPayload)\n          }));\n        }\n\n        events.clear();\n      }\n    }\n    /**\n     * _sendBeacon method.\n     * Util method that check if beacon API is available, build the payload and send it.\n     */\n\n  }, {\n    key: \"_sendBeacon\",\n    value: function _sendBeacon(url, data) {\n      if (navigator && navigator.sendBeacon) {\n        var payload = _JSON$stringify({\n          entries: data,\n          token: this.settings.core.authorizationKey,\n          sdk: this.settings.version\n        });\n\n        return navigator.sendBeacon(url, payload);\n      }\n\n      return false;\n    }\n  }]);\n\n  return BrowserSignalListener;\n}();\n\nexport { BrowserSignalListener as default };"]},"metadata":{},"sourceType":"module"}