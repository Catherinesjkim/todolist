{"ast":null,"code":"import _concatInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/concat\";\nimport ManagerFactory from './manager';\nimport StorageFactory from './storage';\nimport ReadinessGateFacade from './readiness';\nimport SettingsFactory from './utils/settings';\nimport Context from './utils/context';\nimport keyParser from './utils/key/parser';\nimport logFactory, { API } from './utils/logger';\nvar log = logFactory('splitio');\nimport tracker from './utils/timeTracker';\nimport SplitFactoryOnline from './factory/online';\nimport SplitFactoryOffline from './factory/offline';\nimport sdkStatusManager from './readiness/statusManager';\nimport { LOCALHOST_MODE } from './utils/constants';\nimport { validateApiKey, validateKey, validateTrafficType } from './utils/inputValidation';\n\nvar buildInstanceId = function buildInstanceId(key, trafficType) {\n  var _context, _context2;\n\n  return _concatInstanceProperty(_context = _concatInstanceProperty(_context2 = \"\".concat(key.matchingKey ? key.matchingKey : key, \"-\")).call(_context2, key.bucketingKey ? key.bucketingKey : key, \"-\")).call(_context, trafficType !== undefined ? trafficType : '');\n};\n\nexport function SplitFactory(config) {\n  // Cache instances created per factory.\n  var clientInstances = {}; // Tracking times. We need to do it here because we need the storage created.\n\n  var readyLatencyTrackers = {\n    splitsReadyTracker: tracker.start(tracker.TaskNames.SPLITS_READY),\n    segmentsReadyTracker: tracker.start(tracker.TaskNames.SEGMENTS_READY),\n    sdkReadyTracker: tracker.start(tracker.TaskNames.SDK_READY)\n  };\n  var context = new Context(); // Put settings config within context\n\n  var settings = SettingsFactory(config);\n  context.put(context.constants.SETTINGS, settings); // We will just log and allow for the SDK to end up throwing an SDK_TIMEOUT event for devs to handle.\n\n  validateApiKey(settings.core.authorizationKey); // Put storage config within context\n\n  var storage = StorageFactory(context);\n  var gateFactory = ReadinessGateFacade();\n  context.put(context.constants.STORAGE, storage); // Define which type of factory to use\n\n  var splitFactory = settings.mode === LOCALHOST_MODE ? SplitFactoryOffline : SplitFactoryOnline; // Put readiness config within context\n\n  var readiness = gateFactory(settings.startup.readyTimeout);\n  context.put(context.constants.READINESS, readiness);\n  var statusManager = sdkStatusManager(context);\n  context.put(context.constants.STATUS_MANAGER, statusManager);\n\n  var _splitFactory = splitFactory(context, readyLatencyTrackers),\n      mainClientInstance = _splitFactory.api,\n      mainClientMetricCollectors = _splitFactory.metricCollectors; // It makes no sense to have multiple instances of the manager.\n\n\n  var managerInstance = ManagerFactory(storage.splits, context);\n  var parsedDefaultKey = keyParser(settings.core.key);\n  var defaultInstanceId = buildInstanceId(parsedDefaultKey, settings.core.trafficType);\n  clientInstances[defaultInstanceId] = mainClientInstance;\n  log.info('New Split SDK instance created.');\n  return {\n    // Split evaluation and event tracking engine\n    client: function client(key, trafficType) {\n      if (key === undefined) {\n        log.debug('Retrieving default SDK client.');\n        return mainClientInstance;\n      }\n\n      if (typeof storage.shared != 'function') {\n        throw 'Shared Client not supported by the storage mechanism. Create isolated instances instead.';\n      } // Validate the key value\n\n\n      var validKey = validateKey(key, 'Shared Client instantiation');\n\n      if (validKey === false) {\n        throw 'Shared Client needs a valid key.';\n      }\n\n      var validTrafficType;\n\n      if (trafficType !== undefined) {\n        validTrafficType = validateTrafficType(trafficType, 'Shared Client instantiation');\n\n        if (validTrafficType === false) {\n          throw 'Shared Client needs a valid traffic type or no traffic type at all.';\n        }\n      }\n\n      var instanceId = buildInstanceId(validKey, validTrafficType);\n\n      if (!clientInstances[instanceId]) {\n        var sharedSettings = settings.overrideKeyAndTT(validKey, validTrafficType);\n        var sharedContext = new Context();\n        sharedContext.put(context.constants.READY, true); // For SDK inner workings it's supposed to be ready.\n\n        var _readiness = gateFactory(sharedSettings.startup.readyTimeout);\n\n        sharedContext.put(context.constants.READINESS, _readiness);\n        sharedContext.put(sharedContext.constants.STATUS_MANAGER, sdkStatusManager(sharedContext, true));\n        sharedContext.put(context.constants.SETTINGS, sharedSettings);\n        sharedContext.put(context.constants.STORAGE, storage.shared(sharedSettings)); // As shared clients reuse all the storage information, we don't need to check here if we\n        // will use offline or online mode. We should stick with the original decision.\n\n        clientInstances[instanceId] = splitFactory(sharedContext, false, mainClientMetricCollectors).api; // The readiness should depend on the readiness of the parent, instead of showing ready by default.\n\n        clientInstances[instanceId].ready = mainClientInstance.ready;\n        log.info('New shared client instance created.');\n      } else {\n        log.debug('Retrieving existing SDK client.');\n      }\n\n      return clientInstances[instanceId];\n    },\n    // Manager API to explore available information\n    manager: function manager() {\n      log.info('Manager instance retrieved.');\n      return managerInstance;\n    },\n    // Logger wrapper API\n    Logger: API,\n    // Expose SDK settings\n    settings: settings\n  };\n}","map":{"version":3,"sources":["/Users/talianassi/Desktop/todolist/node_modules/@splitsoftware/splitio/es/index.js"],"names":["_concatInstanceProperty","ManagerFactory","StorageFactory","ReadinessGateFacade","SettingsFactory","Context","keyParser","logFactory","API","log","tracker","SplitFactoryOnline","SplitFactoryOffline","sdkStatusManager","LOCALHOST_MODE","validateApiKey","validateKey","validateTrafficType","buildInstanceId","key","trafficType","_context","_context2","concat","matchingKey","call","bucketingKey","undefined","SplitFactory","config","clientInstances","readyLatencyTrackers","splitsReadyTracker","start","TaskNames","SPLITS_READY","segmentsReadyTracker","SEGMENTS_READY","sdkReadyTracker","SDK_READY","context","settings","put","constants","SETTINGS","core","authorizationKey","storage","gateFactory","STORAGE","splitFactory","mode","readiness","startup","readyTimeout","READINESS","statusManager","STATUS_MANAGER","_splitFactory","mainClientInstance","api","mainClientMetricCollectors","metricCollectors","managerInstance","splits","parsedDefaultKey","defaultInstanceId","info","client","debug","shared","validKey","validTrafficType","instanceId","sharedSettings","overrideKeyAndTT","sharedContext","READY","_readiness","ready","manager","Logger"],"mappings":"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","sourcesContent":["import _concatInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/concat\";\nimport ManagerFactory from './manager';\nimport StorageFactory from './storage';\nimport ReadinessGateFacade from './readiness';\nimport SettingsFactory from './utils/settings';\nimport Context from './utils/context';\nimport keyParser from './utils/key/parser';\nimport logFactory, { API } from './utils/logger';\nvar log = logFactory('splitio');\nimport tracker from './utils/timeTracker';\nimport SplitFactoryOnline from './factory/online';\nimport SplitFactoryOffline from './factory/offline';\nimport sdkStatusManager from './readiness/statusManager';\nimport { LOCALHOST_MODE } from './utils/constants';\nimport { validateApiKey, validateKey, validateTrafficType } from './utils/inputValidation';\n\nvar buildInstanceId = function buildInstanceId(key, trafficType) {\n  var _context, _context2;\n\n  return _concatInstanceProperty(_context = _concatInstanceProperty(_context2 = \"\".concat(key.matchingKey ? key.matchingKey : key, \"-\")).call(_context2, key.bucketingKey ? key.bucketingKey : key, \"-\")).call(_context, trafficType !== undefined ? trafficType : '');\n};\n\nexport function SplitFactory(config) {\n  // Cache instances created per factory.\n  var clientInstances = {}; // Tracking times. We need to do it here because we need the storage created.\n\n  var readyLatencyTrackers = {\n    splitsReadyTracker: tracker.start(tracker.TaskNames.SPLITS_READY),\n    segmentsReadyTracker: tracker.start(tracker.TaskNames.SEGMENTS_READY),\n    sdkReadyTracker: tracker.start(tracker.TaskNames.SDK_READY)\n  };\n  var context = new Context(); // Put settings config within context\n\n  var settings = SettingsFactory(config);\n  context.put(context.constants.SETTINGS, settings); // We will just log and allow for the SDK to end up throwing an SDK_TIMEOUT event for devs to handle.\n\n  validateApiKey(settings.core.authorizationKey); // Put storage config within context\n\n  var storage = StorageFactory(context);\n  var gateFactory = ReadinessGateFacade();\n  context.put(context.constants.STORAGE, storage); // Define which type of factory to use\n\n  var splitFactory = settings.mode === LOCALHOST_MODE ? SplitFactoryOffline : SplitFactoryOnline; // Put readiness config within context\n\n  var readiness = gateFactory(settings.startup.readyTimeout);\n  context.put(context.constants.READINESS, readiness);\n  var statusManager = sdkStatusManager(context);\n  context.put(context.constants.STATUS_MANAGER, statusManager);\n\n  var _splitFactory = splitFactory(context, readyLatencyTrackers),\n      mainClientInstance = _splitFactory.api,\n      mainClientMetricCollectors = _splitFactory.metricCollectors; // It makes no sense to have multiple instances of the manager.\n\n\n  var managerInstance = ManagerFactory(storage.splits, context);\n  var parsedDefaultKey = keyParser(settings.core.key);\n  var defaultInstanceId = buildInstanceId(parsedDefaultKey, settings.core.trafficType);\n  clientInstances[defaultInstanceId] = mainClientInstance;\n  log.info('New Split SDK instance created.');\n  return {\n    // Split evaluation and event tracking engine\n    client: function client(key, trafficType) {\n      if (key === undefined) {\n        log.debug('Retrieving default SDK client.');\n        return mainClientInstance;\n      }\n\n      if (typeof storage.shared != 'function') {\n        throw 'Shared Client not supported by the storage mechanism. Create isolated instances instead.';\n      } // Validate the key value\n\n\n      var validKey = validateKey(key, 'Shared Client instantiation');\n\n      if (validKey === false) {\n        throw 'Shared Client needs a valid key.';\n      }\n\n      var validTrafficType;\n\n      if (trafficType !== undefined) {\n        validTrafficType = validateTrafficType(trafficType, 'Shared Client instantiation');\n\n        if (validTrafficType === false) {\n          throw 'Shared Client needs a valid traffic type or no traffic type at all.';\n        }\n      }\n\n      var instanceId = buildInstanceId(validKey, validTrafficType);\n\n      if (!clientInstances[instanceId]) {\n        var sharedSettings = settings.overrideKeyAndTT(validKey, validTrafficType);\n        var sharedContext = new Context();\n        sharedContext.put(context.constants.READY, true); // For SDK inner workings it's supposed to be ready.\n\n        var _readiness = gateFactory(sharedSettings.startup.readyTimeout);\n\n        sharedContext.put(context.constants.READINESS, _readiness);\n        sharedContext.put(sharedContext.constants.STATUS_MANAGER, sdkStatusManager(sharedContext, true));\n        sharedContext.put(context.constants.SETTINGS, sharedSettings);\n        sharedContext.put(context.constants.STORAGE, storage.shared(sharedSettings)); // As shared clients reuse all the storage information, we don't need to check here if we\n        // will use offline or online mode. We should stick with the original decision.\n\n        clientInstances[instanceId] = splitFactory(sharedContext, false, mainClientMetricCollectors).api; // The readiness should depend on the readiness of the parent, instead of showing ready by default.\n\n        clientInstances[instanceId].ready = mainClientInstance.ready;\n        log.info('New shared client instance created.');\n      } else {\n        log.debug('Retrieving existing SDK client.');\n      }\n\n      return clientInstances[instanceId];\n    },\n    // Manager API to explore available information\n    manager: function manager() {\n      log.info('Manager instance retrieved.');\n      return managerInstance;\n    },\n    // Logger wrapper API\n    Logger: API,\n    // Expose SDK settings\n    settings: settings\n  };\n}"]},"metadata":{},"sourceType":"module"}