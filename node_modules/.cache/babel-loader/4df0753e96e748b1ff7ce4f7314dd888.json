{"ast":null,"code":"import _mapInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/map\";\nimport _getIterator from \"@babel/runtime-corejs3/core-js/get-iterator\";\n/**\nCopyright 2016 Split Software\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n**/\n\nimport matchersTransform from '../transforms/matchers';\nimport treatmentsParser from '../treatments';\nimport matcherFactory from '../matchers';\nimport sanitizeValue from '../value';\nimport conditionFactory from '../condition';\nimport ifElseIfCombiner from '../combiners/ifelseif';\nimport andCombiner from '../combiners/and';\nimport thenable from '../../utils/promise/thenable';\n\nfunction parse(conditions, storage) {\n  var predicates = [];\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = _getIterator(conditions), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var condition = _step.value;\n      var matchers = condition.matcherGroup.matchers,\n          partitions = condition.partitions,\n          label = condition.label,\n          conditionType = condition.conditionType; // transform data structure\n\n      matchers = matchersTransform(matchers); // create a set of pure functions from the matcher's dto\n\n      var expressions = _mapInstanceProperty(matchers).call(matchers, function (matcherDto) {\n        var matcher = matcherFactory(matcherDto, storage); // Evaluator function.\n\n        return function (key, attributes, splitEvaluator) {\n          var value = sanitizeValue(key, matcherDto, attributes);\n          var result = value !== undefined ? matcher(value, splitEvaluator) : false;\n\n          if (thenable(result)) {\n            return result.then(function (res) {\n              return Boolean(res ^ matcherDto.negate);\n            });\n          }\n\n          return Boolean(result ^ matcherDto.negate);\n        };\n      }); // if matcher's factory can't instanciate the matchers, the expressions array\n      // will be empty\n\n\n      if (expressions.length === 0) {\n        // reset any data collected during parsing\n        predicates = []; // and break the loop\n\n        break;\n      }\n\n      predicates.push(conditionFactory(andCombiner(expressions), treatmentsParser.parse(partitions), label, conditionType));\n    } // Instanciate evaluator given the set of conditions using if else if logic\n\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n        _iterator[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return ifElseIfCombiner(predicates);\n}\n\nexport default parse;","map":{"version":3,"sources":["/Users/talianassi/node_modules/@splitsoftware/splitio/es/engine/parser/index.js"],"names":["_mapInstanceProperty","_getIterator","matchersTransform","treatmentsParser","matcherFactory","sanitizeValue","conditionFactory","ifElseIfCombiner","andCombiner","thenable","parse","conditions","storage","predicates","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_iterator","_step","next","done","condition","value","matchers","matcherGroup","partitions","label","conditionType","expressions","call","matcherDto","matcher","key","attributes","splitEvaluator","result","then","res","Boolean","negate","length","push","err"],"mappings":"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","sourcesContent":["import _mapInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/map\";\nimport _getIterator from \"@babel/runtime-corejs3/core-js/get-iterator\";\n\n/**\nCopyright 2016 Split Software\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n**/\nimport matchersTransform from '../transforms/matchers';\nimport treatmentsParser from '../treatments';\nimport matcherFactory from '../matchers';\nimport sanitizeValue from '../value';\nimport conditionFactory from '../condition';\nimport ifElseIfCombiner from '../combiners/ifelseif';\nimport andCombiner from '../combiners/and';\nimport thenable from '../../utils/promise/thenable';\n\nfunction parse(conditions, storage) {\n  var predicates = [];\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = _getIterator(conditions), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var condition = _step.value;\n      var matchers = condition.matcherGroup.matchers,\n          partitions = condition.partitions,\n          label = condition.label,\n          conditionType = condition.conditionType; // transform data structure\n\n      matchers = matchersTransform(matchers); // create a set of pure functions from the matcher's dto\n\n      var expressions = _mapInstanceProperty(matchers).call(matchers, function (matcherDto) {\n        var matcher = matcherFactory(matcherDto, storage); // Evaluator function.\n\n        return function (key, attributes, splitEvaluator) {\n          var value = sanitizeValue(key, matcherDto, attributes);\n          var result = value !== undefined ? matcher(value, splitEvaluator) : false;\n\n          if (thenable(result)) {\n            return result.then(function (res) {\n              return Boolean(res ^ matcherDto.negate);\n            });\n          }\n\n          return Boolean(result ^ matcherDto.negate);\n        };\n      }); // if matcher's factory can't instanciate the matchers, the expressions array\n      // will be empty\n\n\n      if (expressions.length === 0) {\n        // reset any data collected during parsing\n        predicates = []; // and break the loop\n\n        break;\n      }\n\n      predicates.push(conditionFactory(andCombiner(expressions), treatmentsParser.parse(partitions), label, conditionType));\n    } // Instanciate evaluator given the set of conditions using if else if logic\n\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n        _iterator[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return ifElseIfCombiner(predicates);\n}\n\nexport default parse;"]},"metadata":{},"sourceType":"module"}