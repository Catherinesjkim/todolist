{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime-corejs3/regenerator\";\nimport _concatInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/concat\";\nimport _setTimeout from \"@babel/runtime-corejs3/core-js-stable/set-timeout\";\nimport _Promise from \"@babel/runtime-corejs3/core-js-stable/promise\";\nimport _asyncToGenerator from \"@babel/runtime-corejs3/helpers/esm/asyncToGenerator\";\nimport _toConsumableArray from \"@babel/runtime-corejs3/helpers/esm/toConsumableArray\";\nimport _Set from \"@babel/runtime-corejs3/core-js-stable/set\";\nimport _getIterator from \"@babel/runtime-corejs3/core-js/get-iterator\";\nimport _JSON$stringify from \"@babel/runtime-corejs3/core-js-stable/json/stringify\";\nimport _reduceInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/reduce\";\n/**\nCopyright 2016 Split Software\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n**/\n\nimport logFactory from '../../utils/logger';\nvar log = logFactory('splitio-producer:split-changes');\nimport splitChangesFetcher from '../fetcher/SplitChanges';\nimport parseSegments from '../../engine/parser/segments';\nimport { SplitError } from '../../utils/lang/Errors';\n\nfunction computeSplitsMutation(entries) {\n  var computed = _reduceInstanceProperty(entries).call(entries, function (accum, split) {\n    if (split.status === 'ACTIVE') {\n      accum.added.push([split.name, _JSON$stringify(split)]);\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = _getIterator(parseSegments(split.conditions)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var segmentName = _step.value;\n          accum.segments.add(segmentName);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    } else {\n      accum.removed.push(split.name);\n    }\n\n    return accum;\n  }, {\n    added: [],\n    removed: [],\n    segments: new _Set()\n  });\n\n  computed.segments = _toConsumableArray(computed.segments);\n  return computed;\n}\n\nfunction SplitChangesUpdaterFactory(context) {\n  var isNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  var _context$getAll = context.getAll(),\n      settings = _context$getAll[context.constants.SETTINGS],\n      readiness = _context$getAll[context.constants.READINESS],\n      storage = _context$getAll[context.constants.STORAGE],\n      metricCollectors = _context$getAll[context.constants.COLLECTORS];\n\n  var splitsEventEmitter = readiness.splits;\n  var startingUp = true;\n  var readyOnAlreadyExistentState = true;\n  return /*#__PURE__*/function () {\n    var _SplitChangesUpdater = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      var retry,\n          since,\n          fetcherPromise,\n          _args = arguments;\n      return _regeneratorRuntime.wrap(function _callee$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              retry = _args.length > 0 && _args[0] !== undefined ? _args[0] : 0;\n              _context2.next = 3;\n              return storage.splits.getChangeNumber();\n\n            case 3:\n              since = _context2.sent;\n              log.debug(\"Spin up split update using since = \".concat(since));\n              fetcherPromise = splitChangesFetcher(settings, since, startingUp, metricCollectors, isNode).then(function (splitChanges) {\n                startingUp = false;\n                var mutation = computeSplitsMutation(splitChanges.splits);\n                log.debug(\"New splits \".concat(mutation.added.length));\n                log.debug(\"Removed splits \".concat(mutation.removed.length));\n                log.debug(\"Segment names collected \".concat(mutation.segments)); // Write into storage\n\n                return _Promise.all([storage.splits.addSplits(mutation.added), storage.splits.removeSplits(mutation.removed), storage.splits.setChangeNumber(splitChanges.till), storage.segments.registerSegments(mutation.segments)]).then(function () {\n                  if (since !== splitChanges.till || readyOnAlreadyExistentState) {\n                    readyOnAlreadyExistentState = false;\n                    splitsEventEmitter.emit(splitsEventEmitter.SDK_SPLITS_ARRIVED);\n                  }\n                });\n              })[\"catch\"](function (error) {\n                if (!(error instanceof SplitError)) {\n                  _setTimeout(function () {\n                    throw error;\n                  }, 0);\n\n                  startingUp = false; // Stop retrying.\n                }\n\n                log.warn(\"Error while doing fetch of Splits \".concat(error));\n\n                if (startingUp && settings.startup.retriesOnFailureBeforeReady > retry) {\n                  var _context;\n\n                  retry += 1;\n                  log.info(_concatInstanceProperty(_context = \"Retrying download of splits #\".concat(retry, \". Reason: \")).call(_context, error));\n                  return SplitChangesUpdater(retry);\n                } else {\n                  startingUp = false;\n                }\n\n                return false;\n              }); // After triggering the requests, if we have cached splits information let's notify that.\n\n              if (startingUp && storage.splits.checkCache()) splitsEventEmitter.emit(splitsEventEmitter.SDK_SPLITS_CACHE_LOADED);\n              return _context2.abrupt(\"return\", fetcherPromise);\n\n            case 8:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    function SplitChangesUpdater() {\n      return _SplitChangesUpdater.apply(this, arguments);\n    }\n\n    return SplitChangesUpdater;\n  }();\n}\n\nexport default SplitChangesUpdaterFactory;","map":{"version":3,"sources":["/Users/talianassi/Desktop/todolist/node_modules/@splitsoftware/splitio/es/producer/updater/SplitChanges.js"],"names":["_regeneratorRuntime","_concatInstanceProperty","_setTimeout","_Promise","_asyncToGenerator","_toConsumableArray","_Set","_getIterator","_JSON$stringify","_reduceInstanceProperty","logFactory","log","splitChangesFetcher","parseSegments","SplitError","computeSplitsMutation","entries","computed","call","accum","split","status","added","push","name","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_iterator","conditions","_step","next","done","segmentName","value","segments","add","err","removed","SplitChangesUpdaterFactory","context","isNode","arguments","length","_context$getAll","getAll","settings","constants","SETTINGS","readiness","READINESS","storage","STORAGE","metricCollectors","COLLECTORS","splitsEventEmitter","splits","startingUp","readyOnAlreadyExistentState","_SplitChangesUpdater","mark","_callee","retry","since","fetcherPromise","_args","wrap","_callee$","_context2","prev","getChangeNumber","sent","debug","concat","then","splitChanges","mutation","all","addSplits","removeSplits","setChangeNumber","till","registerSegments","emit","SDK_SPLITS_ARRIVED","error","warn","startup","retriesOnFailureBeforeReady","_context","info","SplitChangesUpdater","checkCache","SDK_SPLITS_CACHE_LOADED","abrupt","stop","apply"],"mappings":"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","sourcesContent":["import _regeneratorRuntime from \"@babel/runtime-corejs3/regenerator\";\nimport _concatInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/concat\";\nimport _setTimeout from \"@babel/runtime-corejs3/core-js-stable/set-timeout\";\nimport _Promise from \"@babel/runtime-corejs3/core-js-stable/promise\";\nimport _asyncToGenerator from \"@babel/runtime-corejs3/helpers/esm/asyncToGenerator\";\nimport _toConsumableArray from \"@babel/runtime-corejs3/helpers/esm/toConsumableArray\";\nimport _Set from \"@babel/runtime-corejs3/core-js-stable/set\";\nimport _getIterator from \"@babel/runtime-corejs3/core-js/get-iterator\";\nimport _JSON$stringify from \"@babel/runtime-corejs3/core-js-stable/json/stringify\";\nimport _reduceInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/reduce\";\n\n/**\nCopyright 2016 Split Software\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n**/\nimport logFactory from '../../utils/logger';\nvar log = logFactory('splitio-producer:split-changes');\nimport splitChangesFetcher from '../fetcher/SplitChanges';\nimport parseSegments from '../../engine/parser/segments';\nimport { SplitError } from '../../utils/lang/Errors';\n\nfunction computeSplitsMutation(entries) {\n  var computed = _reduceInstanceProperty(entries).call(entries, function (accum, split) {\n    if (split.status === 'ACTIVE') {\n      accum.added.push([split.name, _JSON$stringify(split)]);\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = _getIterator(parseSegments(split.conditions)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var segmentName = _step.value;\n          accum.segments.add(segmentName);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    } else {\n      accum.removed.push(split.name);\n    }\n\n    return accum;\n  }, {\n    added: [],\n    removed: [],\n    segments: new _Set()\n  });\n\n  computed.segments = _toConsumableArray(computed.segments);\n  return computed;\n}\n\nfunction SplitChangesUpdaterFactory(context) {\n  var isNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  var _context$getAll = context.getAll(),\n      settings = _context$getAll[context.constants.SETTINGS],\n      readiness = _context$getAll[context.constants.READINESS],\n      storage = _context$getAll[context.constants.STORAGE],\n      metricCollectors = _context$getAll[context.constants.COLLECTORS];\n\n  var splitsEventEmitter = readiness.splits;\n  var startingUp = true;\n  var readyOnAlreadyExistentState = true;\n  return (\n    /*#__PURE__*/\n    function () {\n      var _SplitChangesUpdater = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee() {\n        var retry,\n            since,\n            fetcherPromise,\n            _args = arguments;\n        return _regeneratorRuntime.wrap(function _callee$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                retry = _args.length > 0 && _args[0] !== undefined ? _args[0] : 0;\n                _context2.next = 3;\n                return storage.splits.getChangeNumber();\n\n              case 3:\n                since = _context2.sent;\n                log.debug(\"Spin up split update using since = \".concat(since));\n                fetcherPromise = splitChangesFetcher(settings, since, startingUp, metricCollectors, isNode).then(function (splitChanges) {\n                  startingUp = false;\n                  var mutation = computeSplitsMutation(splitChanges.splits);\n                  log.debug(\"New splits \".concat(mutation.added.length));\n                  log.debug(\"Removed splits \".concat(mutation.removed.length));\n                  log.debug(\"Segment names collected \".concat(mutation.segments)); // Write into storage\n\n                  return _Promise.all([storage.splits.addSplits(mutation.added), storage.splits.removeSplits(mutation.removed), storage.splits.setChangeNumber(splitChanges.till), storage.segments.registerSegments(mutation.segments)]).then(function () {\n                    if (since !== splitChanges.till || readyOnAlreadyExistentState) {\n                      readyOnAlreadyExistentState = false;\n                      splitsEventEmitter.emit(splitsEventEmitter.SDK_SPLITS_ARRIVED);\n                    }\n                  });\n                })[\"catch\"](function (error) {\n                  if (!(error instanceof SplitError)) {\n                    _setTimeout(function () {\n                      throw error;\n                    }, 0);\n\n                    startingUp = false; // Stop retrying.\n                  }\n\n                  log.warn(\"Error while doing fetch of Splits \".concat(error));\n\n                  if (startingUp && settings.startup.retriesOnFailureBeforeReady > retry) {\n                    var _context;\n\n                    retry += 1;\n                    log.info(_concatInstanceProperty(_context = \"Retrying download of splits #\".concat(retry, \". Reason: \")).call(_context, error));\n                    return SplitChangesUpdater(retry);\n                  } else {\n                    startingUp = false;\n                  }\n\n                  return false;\n                }); // After triggering the requests, if we have cached splits information let's notify that.\n\n                if (startingUp && storage.splits.checkCache()) splitsEventEmitter.emit(splitsEventEmitter.SDK_SPLITS_CACHE_LOADED);\n                return _context2.abrupt(\"return\", fetcherPromise);\n\n              case 8:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      function SplitChangesUpdater() {\n        return _SplitChangesUpdater.apply(this, arguments);\n      }\n\n      return SplitChangesUpdater;\n    }()\n  );\n}\n\nexport default SplitChangesUpdaterFactory;"]},"metadata":{},"sourceType":"module"}