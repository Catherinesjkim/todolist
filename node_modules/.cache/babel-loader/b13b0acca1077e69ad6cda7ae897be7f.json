{"ast":null,"code":"import _Object$create from \"@babel/runtime-corejs3/core-js-stable/object/create\";\nimport _Object$assign from \"@babel/runtime-corejs3/core-js-stable/object/assign\";\nimport _Promise from \"@babel/runtime-corejs3/core-js-stable/promise\";\nimport logFactory from '../utils/logger';\nvar log = logFactory('', {\n  displayAllErrors: true\n});\nvar NEW_LISTENER_EVENT = 'newListener';\nvar REMOVE_LISTENER_EVENT = 'removeListener';\nexport default function callbackHandlerContext(context) {\n  var forSharedClient = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var gate = context.get(context.constants.READINESS).gate;\n  var readyCbCount = 0;\n  var isReady = false;\n  var SDK_READY = gate.SDK_READY,\n      SDK_READY_FROM_CACHE = gate.SDK_READY_FROM_CACHE,\n      SDK_UPDATE = gate.SDK_UPDATE,\n      SDK_READY_TIMED_OUT = gate.SDK_READY_TIMED_OUT;\n  var readyPromise = getReadyPromise();\n  gate.once(SDK_READY, function () {\n    if (readyCbCount === 0) log.warn('No listeners for SDK Readiness detected. Incorrect control treatments could have been logged if you called getTreatment/s while the SDK was not yet ready.');\n    context.put(context.constants.READY, true);\n    isReady = true;\n  });\n  gate.once(SDK_READY_FROM_CACHE, function () {\n    log.info('Split SDK is ready from cache.');\n    context.put(context.constants.READY_FROM_CACHE, true);\n  });\n  gate.on(REMOVE_LISTENER_EVENT, function (event) {\n    if (event === SDK_READY) readyCbCount--;\n  });\n  gate.on(NEW_LISTENER_EVENT, function (event) {\n    if (event === SDK_READY || event === SDK_READY_TIMED_OUT) {\n      if (isReady) {\n        log.error(\"A listener was added for \".concat(event === SDK_READY ? 'SDK_READY' : 'SDK_READY_TIMED_OUT', \" on the SDK, which has already fired and won't be emitted again. The callback won't be executed.\"));\n      } else if (event === SDK_READY) {\n        readyCbCount++;\n      }\n    }\n  });\n\n  function generateReadyPromise() {\n    var hasCatch = false;\n    var promise = new _Promise(function (resolve, reject) {\n      gate.once(SDK_READY, resolve);\n      gate.once(SDK_READY_TIMED_OUT, reject);\n    })[\"catch\"](function (err) {\n      // If the promise has a custom error handler, just propagate\n      if (hasCatch) throw err; // If not handle the error to prevent unhandled promise exception.\n\n      log.error(err);\n    });\n    var originalThen = promise.then; // Using .catch(fn) is the same than using .then(null, fn)\n\n    promise.then = function () {\n      if (arguments.length > 0 && typeof arguments[0] === 'function') readyCbCount++;\n      if (arguments.length > 1 && typeof arguments[1] === 'function') hasCatch = true;\n      return originalThen.apply(this, arguments);\n    };\n\n    return promise;\n  }\n\n  function getReadyPromise() {\n    if (forSharedClient) {\n      return _Promise.resolve();\n    } // Non-shared clients use the full blown ready promise implementation.\n\n\n    return generateReadyPromise();\n  }\n\n  return _Object$assign( // Expose Event Emitter functionality\n  _Object$create(gate), {\n    // Expose the event constants without changing the interface\n    Event: {\n      SDK_READY: SDK_READY,\n      SDK_READY_FROM_CACHE: SDK_READY_FROM_CACHE,\n      SDK_UPDATE: SDK_UPDATE,\n      SDK_READY_TIMED_OUT: SDK_READY_TIMED_OUT\n    },\n    // Expose the ready promise flag\n    ready: function ready() {\n      return readyPromise;\n    }\n  });\n}","map":{"version":3,"sources":["/Users/talianassi/node_modules/@splitsoftware/splitio/es/readiness/statusManager.js"],"names":["_Object$create","_Object$assign","_Promise","logFactory","log","displayAllErrors","NEW_LISTENER_EVENT","REMOVE_LISTENER_EVENT","callbackHandlerContext","context","forSharedClient","arguments","length","undefined","gate","get","constants","READINESS","readyCbCount","isReady","SDK_READY","SDK_READY_FROM_CACHE","SDK_UPDATE","SDK_READY_TIMED_OUT","readyPromise","getReadyPromise","once","warn","put","READY","info","READY_FROM_CACHE","on","event","error","concat","generateReadyPromise","hasCatch","promise","resolve","reject","err","originalThen","then","apply","Event","ready"],"mappings":"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","sourcesContent":["import _Object$create from \"@babel/runtime-corejs3/core-js-stable/object/create\";\nimport _Object$assign from \"@babel/runtime-corejs3/core-js-stable/object/assign\";\nimport _Promise from \"@babel/runtime-corejs3/core-js-stable/promise\";\nimport logFactory from '../utils/logger';\nvar log = logFactory('', {\n  displayAllErrors: true\n});\nvar NEW_LISTENER_EVENT = 'newListener';\nvar REMOVE_LISTENER_EVENT = 'removeListener';\nexport default function callbackHandlerContext(context) {\n  var forSharedClient = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var gate = context.get(context.constants.READINESS).gate;\n  var readyCbCount = 0;\n  var isReady = false;\n  var SDK_READY = gate.SDK_READY,\n      SDK_READY_FROM_CACHE = gate.SDK_READY_FROM_CACHE,\n      SDK_UPDATE = gate.SDK_UPDATE,\n      SDK_READY_TIMED_OUT = gate.SDK_READY_TIMED_OUT;\n  var readyPromise = getReadyPromise();\n  gate.once(SDK_READY, function () {\n    if (readyCbCount === 0) log.warn('No listeners for SDK Readiness detected. Incorrect control treatments could have been logged if you called getTreatment/s while the SDK was not yet ready.');\n    context.put(context.constants.READY, true);\n    isReady = true;\n  });\n  gate.once(SDK_READY_FROM_CACHE, function () {\n    log.info('Split SDK is ready from cache.');\n    context.put(context.constants.READY_FROM_CACHE, true);\n  });\n  gate.on(REMOVE_LISTENER_EVENT, function (event) {\n    if (event === SDK_READY) readyCbCount--;\n  });\n  gate.on(NEW_LISTENER_EVENT, function (event) {\n    if (event === SDK_READY || event === SDK_READY_TIMED_OUT) {\n      if (isReady) {\n        log.error(\"A listener was added for \".concat(event === SDK_READY ? 'SDK_READY' : 'SDK_READY_TIMED_OUT', \" on the SDK, which has already fired and won't be emitted again. The callback won't be executed.\"));\n      } else if (event === SDK_READY) {\n        readyCbCount++;\n      }\n    }\n  });\n\n  function generateReadyPromise() {\n    var hasCatch = false;\n    var promise = new _Promise(function (resolve, reject) {\n      gate.once(SDK_READY, resolve);\n      gate.once(SDK_READY_TIMED_OUT, reject);\n    })[\"catch\"](function (err) {\n      // If the promise has a custom error handler, just propagate\n      if (hasCatch) throw err; // If not handle the error to prevent unhandled promise exception.\n\n      log.error(err);\n    });\n    var originalThen = promise.then; // Using .catch(fn) is the same than using .then(null, fn)\n\n    promise.then = function () {\n      if (arguments.length > 0 && typeof arguments[0] === 'function') readyCbCount++;\n      if (arguments.length > 1 && typeof arguments[1] === 'function') hasCatch = true;\n      return originalThen.apply(this, arguments);\n    };\n\n    return promise;\n  }\n\n  function getReadyPromise() {\n    if (forSharedClient) {\n      return _Promise.resolve();\n    } // Non-shared clients use the full blown ready promise implementation.\n\n\n    return generateReadyPromise();\n  }\n\n  return _Object$assign( // Expose Event Emitter functionality\n  _Object$create(gate), {\n    // Expose the event constants without changing the interface\n    Event: {\n      SDK_READY: SDK_READY,\n      SDK_READY_FROM_CACHE: SDK_READY_FROM_CACHE,\n      SDK_UPDATE: SDK_UPDATE,\n      SDK_READY_TIMED_OUT: SDK_READY_TIMED_OUT\n    },\n    // Expose the ready promise flag\n    ready: function ready() {\n      return readyPromise;\n    }\n  });\n}"]},"metadata":{},"sourceType":"module"}