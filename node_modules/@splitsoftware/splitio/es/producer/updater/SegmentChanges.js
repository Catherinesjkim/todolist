import _regeneratorRuntime from "@babel/runtime-corejs3/regenerator";
import _concatInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/concat";
import _getIterator from "@babel/runtime-corejs3/core-js/get-iterator";
import _setTimeout from "@babel/runtime-corejs3/core-js-stable/set-timeout";
import _Promise from "@babel/runtime-corejs3/core-js-stable/promise";
import _asyncToGenerator from "@babel/runtime-corejs3/helpers/esm/asyncToGenerator";

/**
Copyright 2016 Split Software

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
**/
import logFactory from '../../utils/logger';
var log = logFactory('splitio-producer:segment-changes');
var inputValidationLog = logFactory('', {
  displayAllErrors: true
});
import segmentChangesFetcher from '../fetcher/SegmentChanges';
import { findIndex, startsWith } from '../../utils/lang';
import { SplitError } from '../../utils/lang/Errors';

var SegmentChangesUpdaterFactory = function SegmentChangesUpdaterFactory(context) {
  var _context$getAll = context.getAll(),
      settings = _context$getAll[context.constants.SETTINGS],
      readiness = _context$getAll[context.constants.READINESS],
      storage = _context$getAll[context.constants.STORAGE],
      metricCollectors = _context$getAll[context.constants.COLLECTORS];

  var segmentsEventEmitter = readiness.segments;
  var readyOnAlreadyExistentState = true;
  return (
    /*#__PURE__*/
    function () {
      var _SegmentChangesUpdater = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee2() {
        var updaters, segments, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _loop, _iterator, _step;

        return _regeneratorRuntime.wrap(function _callee2$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                log.debug('Started segments update'); // Async fetchers are collected here.

                updaters = []; // Read list of available segments names to be updated.

                _context6.next = 4;
                return storage.segments.getRegisteredSegments();

              case 4:
                segments = _context6.sent;
                _iteratorNormalCompletion = true;
                _didIteratorError = false;
                _iteratorError = undefined;
                _context6.prev = 8;
                _loop =
                /*#__PURE__*/
                _regeneratorRuntime.mark(function _loop() {
                  var segmentName, since;
                  return _regeneratorRuntime.wrap(function _loop$(_context5) {
                    while (1) {
                      switch (_context5.prev = _context5.next) {
                        case 0:
                          segmentName = _step.value;
                          _context5.next = 3;
                          return storage.segments.getChangeNumber(segmentName);

                        case 3:
                          since = _context5.sent;
                          log.debug("Processing segment ".concat(segmentName));
                          updaters.push(segmentChangesFetcher(settings, segmentName, since, metricCollectors).then(
                          /*#__PURE__*/
                          function () {
                            var _ref = _asyncToGenerator(
                            /*#__PURE__*/
                            _regeneratorRuntime.mark(function _callee(changes) {
                              var changeNumber, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _context, _context2, _context3, x;

                              return _regeneratorRuntime.wrap(function _callee$(_context4) {
                                while (1) {
                                  switch (_context4.prev = _context4.next) {
                                    case 0:
                                      changeNumber = -1;
                                      _iteratorNormalCompletion2 = true;
                                      _didIteratorError2 = false;
                                      _iteratorError2 = undefined;
                                      _context4.prev = 4;
                                      _iterator2 = _getIterator(changes);

                                    case 6:
                                      if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
                                        _context4.next = 22;
                                        break;
                                      }

                                      x = _step2.value;

                                      if (!(x.added.length > 0)) {
                                        _context4.next = 11;
                                        break;
                                      }

                                      _context4.next = 11;
                                      return storage.segments.addToSegment(segmentName, x.added);

                                    case 11:
                                      if (!(x.removed.length > 0)) {
                                        _context4.next = 14;
                                        break;
                                      }

                                      _context4.next = 14;
                                      return storage.segments.removeFromSegment(segmentName, x.removed);

                                    case 14:
                                      if (!(x.added.length > 0 || x.removed.length > 0)) {
                                        _context4.next = 18;
                                        break;
                                      }

                                      _context4.next = 17;
                                      return storage.segments.setChangeNumber(segmentName, x.till);

                                    case 17:
                                      changeNumber = x.till;

                                    case 18:
                                      log.debug(_concatInstanceProperty(_context = _concatInstanceProperty(_context2 = _concatInstanceProperty(_context3 = "Processed ".concat(segmentName, " with till = ")).call(_context3, x.till, ". Added: ")).call(_context2, x.added.length, ". Removed: ")).call(_context, x.removed.length));

                                    case 19:
                                      _iteratorNormalCompletion2 = true;
                                      _context4.next = 6;
                                      break;

                                    case 22:
                                      _context4.next = 28;
                                      break;

                                    case 24:
                                      _context4.prev = 24;
                                      _context4.t0 = _context4["catch"](4);
                                      _didIteratorError2 = true;
                                      _iteratorError2 = _context4.t0;

                                    case 28:
                                      _context4.prev = 28;
                                      _context4.prev = 29;

                                      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                                        _iterator2["return"]();
                                      }

                                    case 31:
                                      _context4.prev = 31;

                                      if (!_didIteratorError2) {
                                        _context4.next = 34;
                                        break;
                                      }

                                      throw _iteratorError2;

                                    case 34:
                                      return _context4.finish(31);

                                    case 35:
                                      return _context4.finish(28);

                                    case 36:
                                      return _context4.abrupt("return", changeNumber);

                                    case 37:
                                    case "end":
                                      return _context4.stop();
                                  }
                                }
                              }, _callee, null, [[4, 24, 28, 36], [29,, 31, 35]]);
                            }));

                            return function (_x) {
                              return _ref.apply(this, arguments);
                            };
                          }()));

                        case 6:
                        case "end":
                          return _context5.stop();
                      }
                    }
                  }, _loop);
                });
                _iterator = _getIterator(segments);

              case 11:
                if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                  _context6.next = 16;
                  break;
                }

                return _context6.delegateYield(_loop(), "t0", 13);

              case 13:
                _iteratorNormalCompletion = true;
                _context6.next = 11;
                break;

              case 16:
                _context6.next = 22;
                break;

              case 18:
                _context6.prev = 18;
                _context6.t1 = _context6["catch"](8);
                _didIteratorError = true;
                _iteratorError = _context6.t1;

              case 22:
                _context6.prev = 22;
                _context6.prev = 23;

                if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                  _iterator["return"]();
                }

              case 25:
                _context6.prev = 25;

                if (!_didIteratorError) {
                  _context6.next = 28;
                  break;
                }

                throw _iteratorError;

              case 28:
                return _context6.finish(25);

              case 29:
                return _context6.finish(22);

              case 30:
                return _context6.abrupt("return", _Promise.all(updaters).then(function (shouldUpdateFlags) {
                  if (findIndex(shouldUpdateFlags, function (v) {
                    return v !== -1;
                  }) !== -1 || readyOnAlreadyExistentState) {
                    readyOnAlreadyExistentState = false;
                    segmentsEventEmitter.emit(segmentsEventEmitter.SDK_SEGMENTS_ARRIVED);
                  }
                })["catch"](function (error) {
                  if (!(error instanceof SplitError)) _setTimeout(function () {
                    throw error;
                  }, 0);

                  if (startsWith(error.message, '403')) {
                    context.put(context.constants.DESTROYED, true);
                    inputValidationLog.error('Factory instantiation: you passed a Browser type authorizationKey, please grab an Api Key from the Split web console that is of type SDK.');
                  }
                }));

              case 31:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee2, null, [[8, 18, 22, 30], [23,, 25, 29]]);
      }));

      function SegmentChangesUpdater() {
        return _SegmentChangesUpdater.apply(this, arguments);
      }

      return SegmentChangesUpdater;
    }()
  );
};

export default SegmentChangesUpdaterFactory;