"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js-stable/object/define-property");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.string.iterator");

require("core-js/modules/web.dom-collections.iterator");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs3/regenerator"));

var _promise = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/promise"));

require("regenerator-runtime/runtime");

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/asyncToGenerator"));

var _create = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/create"));

var _assign = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/assign"));

var _setTimeout2 = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/set-timeout"));

var _client = _interopRequireDefault(require("../client"));

var _producer = _interopRequireDefault(require("../producer"));

var _Partial = _interopRequireDefault(require("../producer/browser/Partial"));

var _metrics = _interopRequireDefault(require("../metrics"));

var _events = _interopRequireDefault(require("../events"));

var _listeners = _interopRequireDefault(require("../listeners"));

var _constants = require("../utils/constants");

var _inputValidation = require("../utils/inputValidation");

//
// Create SDK instance based on the provided configurations
//
function SplitFactoryOnline(context, readyTrackers, mainClientMetricCollectors) {
  var sharedInstance = !!mainClientMetricCollectors;
  var settings = context.get(context.constants.SETTINGS);
  var readiness = context.get(context.constants.READINESS);
  var storage = context.get(context.constants.STORAGE);
  var statusManager = context.get(context.constants.STATUS_MANAGER); // We are only interested in exposable EventEmitter

  var gate = readiness.gate,
      splits = readiness.splits,
      segments = readiness.segments; // Events name

  var SDK_READY = gate.SDK_READY; // Shared instances use parent metrics collectors

  var metrics = sharedInstance ? undefined : (0, _metrics.default)(context); // Shared instances use parent events queue

  var events = sharedInstance ? undefined : (0, _events.default)(context); // Signal listener only needed for main instances

  var signalsListener = sharedInstance ? undefined : new _listeners.default(context);
  var producer;

  switch (settings.mode) {
    case _constants.PRODUCER_MODE:
    case _constants.STANDALONE_MODE:
      {
        context.put(context.constants.COLLECTORS, metrics && metrics.collectors); // We don't fully instantiate producer if we are creating a shared instance.

        producer = sharedInstance ? (0, _Partial.default)(context) : (0, _producer.default)(context);
        break;
      }

    case _constants.CONSUMER_MODE:
      {
        context.put(context.constants.READY, true); // For SDK inner workings it's supposed to be ready.

        (0, _setTimeout2.default)(function () {
          // Allow for the sync statements to run so client is returned before these are emitted and callbacks executed.
          splits.emit(splits.SDK_SPLITS_ARRIVED, false);
          segments.emit(segments.SDK_SEGMENTS_ARRIVED, false);
        }, 0);
        break;
      }
  }

  if (readyTrackers && producer && !sharedInstance) {
    // Only track ready events for non-shared and non-consumer clients
    var sdkReadyTracker = readyTrackers.sdkReadyTracker,
        splitsReadyTracker = readyTrackers.splitsReadyTracker,
        segmentsReadyTracker = readyTrackers.segmentsReadyTracker; // Defered setup of collectors for this task, as it is the only ready latency we store on BE.

    sdkReadyTracker.setCollectorForTask(metrics.collectors);
    gate.on(SDK_READY, sdkReadyTracker);
    splits.once(splits.SDK_SPLITS_ARRIVED, splitsReadyTracker);
    segments.once(segments.SDK_SEGMENTS_ARRIVED, segmentsReadyTracker);
  } // Start background jobs tasks


  producer && producer.start();
  metrics && metrics.start();
  events && context.put(context.constants.EVENTS, events) && events.start(); // If no collectors are stored we are on a shared instance, save main one.

  context.put(context.constants.COLLECTORS, mainClientMetricCollectors);
  var api = (0, _assign.default)( // Proto linkage of the EventEmitter to prevent any change
  (0, _create.default)(statusManager), // getTreatment/s & track
  (0, _client.default)(context), // Utilities
  {
    // Destroy instance
    destroy: function () {
      var _destroy = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee() {
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                // Stop background jobs
                producer && producer.stop();
                metrics && metrics.stop();
                events && events.stop(); // Send impressions and events in parallel.

                _context.next = 5;
                return _promise.default.all([metrics && metrics.flush(), events && events.flush()]);

              case 5:
                // Cleanup event listeners
                readiness.destroy();
                signalsListener && signalsListener.stop(); // Cleanup storage

                storage.destroy && storage.destroy(); // Mark the factory as destroyed.

                context.put(context.constants.DESTROYED, true); // And release the API Key

                !sharedInstance && (0, _inputValidation.releaseApiKey)(settings.core.authorizationKey);

              case 10:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function destroy() {
        return _destroy.apply(this, arguments);
      }

      return destroy;
    }()
  }); // We'll start the signals listener if the client is not a shared instance.
  // For now, we will only call destroy.

  !sharedInstance && signalsListener.start(api.destroy);
  return {
    api: api,
    metricCollectors: metrics && metrics.collectors
  };
}

var _default = SplitFactoryOnline;
exports.default = _default;