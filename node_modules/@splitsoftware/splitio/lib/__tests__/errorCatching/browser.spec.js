"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

var _setTimeout2 = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/set-timeout"));

var _promise = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/promise"));

var _tape = _interopRequireDefault(require("tape"));

var _includes = _interopRequireDefault(require("lodash/includes"));

var _axiosMockAdapter = _interopRequireDefault(require("axios-mock-adapter"));

var _splitChangesSince = _interopRequireDefault(require("./splitChanges.since.-1.json"));

var _mySegmentsNicoSplitIo = _interopRequireDefault(require("./mySegments.nico@split.io.json"));

var _splitChangesSince2 = _interopRequireDefault(require("./splitChanges.since.1500492097547.json"));

var _splitChangesSince3 = _interopRequireDefault(require("./splitChanges.since.1500492297547.json"));

var _ = require("../../");

var _settings = _interopRequireDefault(require("../../utils/settings"));

var _transport = require("../../services/transport");

// Here we are testing exceptions and the handler should be ours, we need to avoid tape-catch
// Set the mock adapter on the current axios instance
var mock = new _axiosMockAdapter.default((0, _transport.__getAxiosInstance)());
var settings = (0, _settings.default)({
  core: {
    authorizationKey: '<fake-token>'
  }
});
mock.onGet(settings.url('/splitChanges?since=-1')).reply(function () {
  return new _promise.default(function (res) {
    (0, _setTimeout2.default)(function () {
      return res([200, _splitChangesSince.default]);
    }, 1000);
  });
});
mock.onGet(settings.url('/splitChanges?since=1500492097547')).reply(200, _splitChangesSince2.default);
mock.onGet(settings.url('/splitChanges?since=1500492297547')).reply(200, _splitChangesSince3.default);
mock.onGet(settings.url('/mySegments/nico@split.io')).reply(200, _mySegmentsNicoSplitIo.default);
mock.onPost().reply(200);
var assertionsPlanned = 3;
var errCount = 0;
var factory = (0, _.SplitFactory)({
  core: {
    authorizationKey: '<fake-token-1>',
    key: 'nico@split.io'
  },
  startup: {
    eventsFirstPushWindow: 100000,
    readyTimeout: 0.5,
    requestTimeoutBeforeReady: 100000
  },
  scheduler: {
    featuresRefreshRate: 1.5,
    segmentsRefreshRate: 100000,
    metricsRefreshRate: 100000,
    impressionsRefreshRate: 100000,
    eventsPushRate: 100000
  }
});
(0, _tape.default)('Error catching on callbacks - Browsers', function (assert) {
  var previousErrorHandler = window.onerror || null;
  var client = factory.client();

  var exceptionHandler = function exceptionHandler(err) {
    if ((0, _includes.default)(err, 'willThrowFor')) {
      errCount++;
      assert.pass("But this should be loud, all should throw as Uncaught Exception: ".concat(err));

      if (errCount === assertionsPlanned) {
        var wrapUp = function wrapUp() {
          window.onerror = previousErrorHandler;
          mock.restore();
          assert.end();
        };

        client.destroy().then(wrapUp).catch(wrapUp);
      }

      return true;
    }

    assert.fail(err);
    return false;
  }; // Karma is missbehaving and overwriting our custom error handler on some scenarios.


  function attachErrorHandlerIfApplicable() {
    if (window.onerror !== exceptionHandler) {
      previousErrorHandler = window.onerror;
      window.onerror = exceptionHandler;
    }
  }

  client.on(client.Event.SDK_READY_TIMED_OUT, function () {
    attachErrorHandlerIfApplicable();
    null.willThrowForTimedOut();
  });
  client.once(client.Event.SDK_READY, function () {
    attachErrorHandlerIfApplicable();
    null.willThrowForReady();
  });
  client.once(client.Event.SDK_UPDATE, function () {
    attachErrorHandlerIfApplicable();
    null.willThrowForUpdate();
  });
  attachErrorHandlerIfApplicable();
});