"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
var splitio_1 = require("@splitsoftware/splitio");
var react_1 = __importDefault(require("react"));
var SplitContext_1 = __importDefault(require("./SplitContext"));
var constants_1 = require("./constants");
var utils_1 = require("./utils");
/**
 * SplitFactory will initialize the Split SDK and listen for its events in order to update the Split Context.
 * SplitFactory must wrap other components and functions from this library, since they access the Split Context
 * and its elements (factory, clients, etc).
 *
 * @see {@link https://help.split.io/hc/en-us/articles/360020448791-JavaScript-SDK}
 */
var SplitFactory = /** @class */ (function (_super) {
    __extends(SplitFactory, _super);
    function SplitFactory(props) {
        var _this = _super.call(this, props) || this;
        _this.sdkUpdate = function () {
            _this.setState({ lastUpdate: Date.now() });
        };
        // Log warning and error
        var propFactory = props.factory, config = props.config, updateOnSdkReady = props.updateOnSdkReady, updateOnSdkTimedout = props.updateOnSdkTimedout, updateOnSdkUpdate = props.updateOnSdkUpdate;
        if (!config && !propFactory) {
            console.error(constants_1.ERROR_SF_NO_CONFIG_AND_FACTORY);
        }
        if (config && propFactory) {
            console.log(constants_1.WARN_SF_CONFIG_AND_FACTORY);
        }
        // Instantiate factory and main client.
        var factory = propFactory || (config ? splitio_1.SplitFactory(config) : null);
        // Don't try this at home. Only override the version when we create our own factory.
        if (config && factory) {
            factory.settings.version = constants_1.VERSION;
        }
        var client = factory ? utils_1.getClientWithStatus(factory) : null;
        if (client) {
            _this.subscribeToEvents(client, updateOnSdkUpdate, updateOnSdkTimedout, updateOnSdkReady);
        }
        _this.state = {
            client: client,
            factory: factory,
            isReady: client ? client.isReady : false,
            isTimedout: client ? client.isTimedout : false,
            lastUpdate: 0
        };
        return _this;
    }
    // Listen SDK events. This method will be updated when SDK provides self synchronous status
    SplitFactory.prototype.subscribeToEvents = function (client, updateOnSdkUpdate, updateOnSdkTimedout, updateOnSdkReady) {
        var _this = this;
        if (!client.isReady) { // client is not ready
            /**
             * client still might be ready if it was created before using `getClientWithStatus` function
             * (for example if the client was instantiated outside SplitClient),
             * thus we have to use the ready() promise instead of an event listener.
             */
            client.ready().then(function () {
                // Update isReady if the client was not changed and updateOnSdkReady is true
                if (_this.state.client === client && updateOnSdkReady) {
                    _this.setState({ isReady: true, isTimedout: false, lastUpdate: Date.now() });
                }
            }, function () {
                // Update isTimedout if the client was not changed and updateOnSdkTimedout is true
                if (_this.state.client === client) {
                    if (updateOnSdkTimedout) {
                        _this.setState({ isTimedout: true, lastUpdate: Date.now() });
                    }
                    // register a listener for SDK_READY event, that might trigger after a timeout
                    client.once(client.Event.SDK_READY, function () {
                        // Update isReady if the client was not changed and updateOnSdkReady is true
                        if (_this.state.client === client && updateOnSdkReady) {
                            _this.setState({ isReady: true, isTimedout: false, lastUpdate: Date.now() });
                        }
                    });
                }
            });
        }
        // register a listener for SDK_UPDATE event
        if (updateOnSdkUpdate) {
            client.on(client.Event.SDK_UPDATE, this.sdkUpdate);
        }
    };
    SplitFactory.prototype.render = function () {
        var children = this.props.children;
        var _a = this.state, factory = _a.factory, isReady = _a.isReady, isTimedout = _a.isTimedout, lastUpdate = _a.lastUpdate;
        return (react_1["default"].createElement(SplitContext_1["default"].Provider, { value: this.state }, typeof children === 'function' ?
            children({ factory: factory, isReady: isReady, isTimedout: isTimedout, lastUpdate: lastUpdate }) :
            this.props.children));
    };
    SplitFactory.defaultProps = {
        updateOnSdkUpdate: false,
        updateOnSdkTimedout: false,
        updateOnSdkReady: true,
        children: null
    };
    return SplitFactory;
}(react_1["default"].Component));
exports["default"] = SplitFactory;
