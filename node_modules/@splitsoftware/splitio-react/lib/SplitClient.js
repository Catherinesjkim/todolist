"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
var react_1 = __importDefault(require("react"));
var SplitContext_1 = __importDefault(require("./SplitContext"));
var constants_1 = require("./constants");
var utils_1 = require("./utils");
/**
 * SplitClient will initialize a new Split Client and listen for its events in order to update the Split Context.
 * Children components will have access to this new client when accessing the Split Context.
 *
 * @see {@link https://help.split.io/hc/en-us/articles/360020448791-JavaScript-SDK#advanced-instantiate-multiple-sdk-clients}
 */
var SplitClient = /** @class */ (function (_super) {
    __extends(SplitClient, _super);
    function SplitClient(props) {
        var _this = _super.call(this, props) || this;
        _this.sdkUpdate = function () {
            _this.setState({ lastUpdate: Date.now() });
        };
        var splitKey = props.splitKey, trafficType = props.trafficType, updateOnSdkUpdate = props.updateOnSdkUpdate, updateOnSdkTimedout = props.updateOnSdkTimedout, updateOnSdkReady = props.updateOnSdkReady, factory = props.splitContext.factory;
        // Log error if factory is not available
        if (!factory) {
            console.error(constants_1.ERROR_SC_NO_FACTORY);
        }
        // Init new client
        var client = factory ? utils_1.getClientWithStatus(factory, splitKey, trafficType) : null;
        if (client) {
            _this.subscribeToEvents(client, updateOnSdkUpdate, updateOnSdkTimedout, updateOnSdkReady);
        }
        _this.state = __assign(__assign({}, props.splitContext), { client: client, isReady: client ? client.isReady : false, isTimedout: client ? client.isTimedout : false });
        return _this;
    }
    // Listen SDK events. This method will be updated when SDK provides self synchronous status
    SplitClient.prototype.subscribeToEvents = function (client, updateOnSdkUpdate, updateOnSdkTimedout, updateOnSdkReady) {
        var _this = this;
        if (!client.isReady) { // client is not ready
            /**
             * client still might be ready if it was created before using `getClientWithStatus` function
             * (for example if the client was instantiated outside SplitClient),
             * thus we have to use the ready() promise instead of an event listener.
             */
            client.ready().then(function () {
                // Update isReady if the client was not changed and updateOnSdkReady is true
                if (_this.state.client === client && updateOnSdkReady) {
                    _this.setState({ isReady: true, isTimedout: false, lastUpdate: Date.now() });
                }
            }, function () {
                // Update isTimedout if the client was not changed and updateOnSdkTimedout is true
                if (_this.state.client === client) {
                    if (updateOnSdkTimedout) {
                        _this.setState({ isTimedout: true, lastUpdate: Date.now() });
                    }
                    // register a listener for SDK_READY event, that might trigger after a timeout
                    client.once(client.Event.SDK_READY, function () {
                        // Update isReady if the client was not changed and updateOnSdkReady is true
                        if (_this.state.client === client && updateOnSdkReady) {
                            _this.setState({ isReady: true, isTimedout: false, lastUpdate: Date.now() });
                        }
                    });
                }
            });
        }
        // register a listener for SDK_UPDATE event
        if (updateOnSdkUpdate) {
            client.on(client.Event.SDK_UPDATE, this.sdkUpdate);
        }
    };
    SplitClient.prototype.shouldComponentUpdate = function (_a, nextState) {
        var factory = _a.splitContext.factory, splitKey = _a.splitKey, trafficType = _a.trafficType, updateOnSdkReady = _a.updateOnSdkReady, updateOnSdkTimedout = _a.updateOnSdkTimedout, updateOnSdkUpdate = _a.updateOnSdkUpdate;
        var client = factory ? utils_1.getClientWithStatus(factory, splitKey, trafficType) : null;
        if (client !== nextState.client && client) {
            this.subscribeToEvents(client, updateOnSdkUpdate, updateOnSdkTimedout, updateOnSdkReady);
            // Deregister listener for previous client
            if (nextState.client) {
                nextState.client.removeListener(client.Event.SDK_UPDATE, this.sdkUpdate);
            }
            this.setState({
                client: client,
                isReady: client ? client.isReady : false,
                isTimedout: client ? client.isTimedout : false
            });
            return false;
        }
        // Update when the client or its status change
        // (no need to compara isReady or isTimedout, lastUpdate is enough).
        // Don't update when updateOnSdk** props change.
        return this.state.client !== nextState.client ||
            this.state.lastUpdate !== nextState.lastUpdate;
    };
    SplitClient.prototype.render = function () {
        var children = this.props.children;
        var _a = this.state, client = _a.client, isReady = _a.isReady, isTimedout = _a.isTimedout, lastUpdate = _a.lastUpdate;
        return (react_1["default"].createElement(SplitContext_1["default"].Provider, { value: this.state }, typeof children === 'function' ?
            children({ client: client, isReady: isReady, isTimedout: isTimedout, lastUpdate: lastUpdate }) :
            children));
    };
    SplitClient.contextType = SplitContext_1["default"];
    SplitClient.defaultProps = {
        updateOnSdkUpdate: false,
        updateOnSdkTimedout: false,
        updateOnSdkReady: true,
        children: null
    };
    return SplitClient;
}(react_1["default"].Component));
// Wrapper to access Split context on SplitClient constructor
exports["default"] = (function (props) { return (react_1["default"].createElement(SplitContext_1["default"].Consumer, null, function (splitContext) {
    return react_1["default"].createElement(SplitClient, __assign({}, props, { splitContext: splitContext }));
})); });
